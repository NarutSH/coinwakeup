{"ast":null,"code":"/*!\n* chartjs-plugin-annotation v1.0.2\n* https://www.chartjs.org/chartjs-plugin-annotation/index\n * (c) 2021 chartjs-plugin-annotation Contributors\n * Released under the MIT License\n */\nimport { Element, Chart, defaults, Animations } from 'chart.js';\nimport { distanceBetweenPoints, callback, isFinite, toFontString, isArray, toRadians, isObject, clipArea, unclipArea, valueOrDefault } from 'chart.js/helpers';\nconst clickHooks = ['click', 'dblclick'];\nconst moveHooks = ['enter', 'leave'];\nconst hooks = clickHooks.concat(moveHooks);\n\nfunction updateListeners(chart, state, options) {\n  const annotations = state.annotations || [];\n  state.listened = false;\n  state.moveListened = false;\n  hooks.forEach(hook => {\n    if (typeof options[hook] === 'function') {\n      state.listened = true;\n      state.listeners[hook] = options[hook];\n    }\n  });\n  moveHooks.forEach(hook => {\n    if (typeof options[hook] === 'function') {\n      state.moveListened = true;\n    }\n  });\n\n  if (!state.listened || !state.moveListened) {\n    annotations.forEach(scope => {\n      if (!state.listened) {\n        clickHooks.forEach(hook => {\n          if (typeof scope[hook] === 'function') {\n            state.listened = true;\n          }\n        });\n      }\n\n      if (!state.moveListened) {\n        moveHooks.forEach(hook => {\n          if (typeof scope[hook] === 'function') {\n            state.listened = true;\n            state.moveListened = true;\n          }\n        });\n      }\n    });\n  }\n}\n\nfunction handleEvent(chart, state, event, options) {\n  if (state.listened) {\n    switch (event.type) {\n      case 'mousemove':\n      case 'mouseout':\n        handleMoveEvents(chart, state, event);\n        break;\n\n      case 'click':\n        handleClickEvents(chart, state, event, options);\n        break;\n    }\n  }\n}\n\nfunction handleMoveEvents(chart, state, event) {\n  if (!state.moveListened) {\n    return;\n  }\n\n  let element;\n\n  if (event.type === 'mousemove') {\n    element = getNearestItem(state.elements, event);\n  }\n\n  const previous = state.hovered;\n  state.hovered = element;\n  dispatchMoveEvents(chart, state, previous, element);\n}\n\nfunction dispatchMoveEvents(chart, state, previous, element) {\n  if (previous && previous !== element) {\n    dispatchEvent(chart, state, previous.options.leave || state.listeners.leave, previous);\n  }\n\n  if (element && element !== previous) {\n    dispatchEvent(chart, state, element.options.enter || state.listeners.enter, element);\n  }\n}\n\nfunction handleClickEvents(chart, state, event, options) {\n  const listeners = state.listeners;\n  const element = getNearestItem(state.elements, event);\n\n  if (element) {\n    const elOpts = element.options;\n    const dblclick = elOpts.dblclick || listeners.dblclick;\n    const click = elOpts.click || listeners.click;\n\n    if (element.clickTimeout) {\n      // 2nd click before timeout, so its a double click\n      clearTimeout(element.clickTimeout);\n      delete element.clickTimeout;\n      dispatchEvent(chart, state, dblclick, element);\n    } else if (dblclick) {\n      // if there is a dblclick handler, wait for dblClickSpeed ms before deciding its a click\n      element.clickTimeout = setTimeout(() => {\n        delete element.clickTimeout;\n        dispatchEvent(chart, state, click, element);\n      }, options.dblClickSpeed);\n    } else {\n      // no double click handler, just call the click handler directly\n      dispatchEvent(chart, state, click, element);\n    }\n  }\n}\n\nfunction dispatchEvent(chart, _state, handler, element) {\n  callback(handler, [{\n    chart,\n    element\n  }]);\n}\n\nfunction getNearestItem(elements, position) {\n  let minDistance = Number.POSITIVE_INFINITY;\n  return elements.filter(element => element.options.display && element.inRange(position.x, position.y)).reduce((nearestItems, element) => {\n    const center = element.getCenterPoint();\n    const distance = distanceBetweenPoints(position, center);\n\n    if (distance < minDistance) {\n      nearestItems = [element];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      // Can have multiple items at the same distance in which case we sort by size\n      nearestItems.push(element);\n    }\n\n    return nearestItems;\n  }, []).sort((a, b) => a._index - b._index).slice(0, 1)[0]; // return only the top item\n}\n\nconst PI$1 = Math.PI;\nconst HALF_PI = PI$1 / 2;\n\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ? scale.getPixelForValue(value) : fallback;\n}\n/**\n * Creates a \"path\" for a rectangle with rounded corners at position (x, y) with a\n * given size (width, height) and the same `radius` for all corners.\n * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.\n * @param {number} x - The x axis of the coordinate for the rectangle starting point.\n * @param {number} y - The y axis of the coordinate for the rectangle starting point.\n * @param {number} width - The rectangle's width.\n * @param {number} height - The rectangle's height.\n * @param {number} radius - The rounded amount (in pixels) for the four corners.\n * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?\n */\n\n\nfunction roundedRect(ctx, x, y, width, height, radius) {\n  ctx.beginPath();\n\n  if (radius) {\n    const r = Math.min(radius, height / 2, width / 2);\n    const left = x + r;\n    const top = y + r;\n    const right = x + width - r;\n    const bottom = y + height - r;\n    ctx.moveTo(x, top);\n\n    if (left < right && top < bottom) {\n      ctx.arc(left, top, r, -PI$1, -HALF_PI);\n      ctx.arc(right, top, r, -HALF_PI, 0);\n      ctx.arc(right, bottom, r, 0, HALF_PI);\n      ctx.arc(left, bottom, r, HALF_PI, PI$1);\n    } else if (left < right) {\n      ctx.moveTo(left, y);\n      ctx.arc(right, top, r, -HALF_PI, HALF_PI);\n      ctx.arc(left, top, r, HALF_PI, PI$1 + HALF_PI);\n    } else if (top < bottom) {\n      ctx.arc(left, top, r, -PI$1, 0);\n      ctx.arc(left, bottom, r, 0, PI$1);\n    } else {\n      ctx.arc(left, top, r, -PI$1, PI$1);\n    }\n\n    ctx.closePath();\n    ctx.moveTo(x, y);\n  } else {\n    ctx.rect(x, y, width, height);\n  }\n}\n/**\n * Rotate a `point` relative to `center` point by `angle`\n * @param {{x: number, y: number}} point - the point to rotate\n * @param {{x: number, y: number}} center - center point for rotation\n * @param {number} angle - angle for rotation, in radians\n * @returns {{x: number, y: number}} rotated point\n */\n\n\nfunction rotated(point, center, angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  var cx = center.x;\n  var cy = center.y;\n  return {\n    x: cx + cos * (point.x - cx) - sin * (point.y - cy),\n    y: cy + sin * (point.x - cx) + cos * (point.y - cy)\n  };\n}\n\nclass BoxAnnotation extends Element {\n  inRange(mouseX, mouseY, useFinalPosition) {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this.getProps(['x', 'y', 'width', 'height'], useFinalPosition);\n    return mouseX >= x && mouseX <= x + width && mouseY >= y && mouseY <= y + height;\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this.getProps(['x', 'y', 'width', 'height'], useFinalPosition);\n    return {\n      x: x + width / 2,\n      y: y + height / 2\n    };\n  }\n\n  draw(ctx) {\n    const {\n      x,\n      y,\n      width,\n      height,\n      options\n    } = this;\n    ctx.save();\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.fillStyle = options.backgroundColor;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n    roundedRect(ctx, x, y, width, height, options.cornerRadius);\n    ctx.fill(); // If no border, don't draw it\n\n    if (options.borderWidth) {\n      ctx.stroke();\n    }\n\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    const xScale = chart.scales[options.xScaleID];\n    const yScale = chart.scales[options.yScaleID];\n    let {\n      top: y,\n      left: x,\n      bottom: y2,\n      right: x2\n    } = chart.chartArea;\n    let min, max;\n\n    if (!xScale && !yScale) {\n      return {\n        options: {}\n      };\n    }\n\n    if (xScale) {\n      min = scaleValue(xScale, options.xMin, x);\n      max = scaleValue(xScale, options.xMax, x2);\n      x = Math.min(min, max);\n      x2 = Math.max(min, max);\n    }\n\n    if (yScale) {\n      min = scaleValue(yScale, options.yMin, y2);\n      max = scaleValue(yScale, options.yMax, y);\n      y = Math.min(min, max);\n      y2 = Math.max(min, max);\n    }\n\n    return {\n      x,\n      y,\n      x2,\n      y2,\n      width: x2 - x,\n      height: y2 - y\n    };\n  }\n\n}\n\nBoxAnnotation.id = 'boxAnnotation';\nBoxAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderDash: [],\n  borderDashOffset: 0,\n  borderWidth: 1,\n  cornerRadius: 0,\n  xScaleID: 'x',\n  xMin: undefined,\n  xMax: undefined,\n  yScaleID: 'y',\n  yMin: undefined,\n  yMax: undefined\n};\nBoxAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nconst PI = Math.PI;\n\nconst clamp = (x, from, to) => Math.min(to, Math.max(from, x));\n\nconst pointInLine = (p1, p2, t) => ({\n  x: p1.x + t * (p2.x - p1.x),\n  y: p1.y + t * (p2.y - p1.y)\n});\n\nconst interpolateX = (y, p1, p2) => pointInLine(p1, p2, Math.abs((y - p1.y) / (p2.y - p1.y))).x;\n\nconst interpolateY = (x, p1, p2) => pointInLine(p1, p2, Math.abs((x - p1.x) / (p2.x - p1.x))).y;\n\nconst toPercent = s => typeof s === 'string' && s.endsWith('%') && parseFloat(s) / 100;\n\nfunction limitPointToArea({\n  x,\n  y\n}, p2, {\n  top,\n  right,\n  bottom,\n  left\n}) {\n  if (x < left) {\n    y = p2.x < left ? NaN : interpolateY(left, {\n      x,\n      y\n    }, p2);\n    x = left;\n  }\n\n  if (x > right) {\n    y = p2.x > right ? NaN : interpolateY(right, {\n      x,\n      y\n    }, p2);\n    x = right;\n  }\n\n  if (y < top) {\n    x = p2.y < top ? NaN : interpolateX(top, {\n      x,\n      y\n    }, p2);\n    y = top;\n  }\n\n  if (y > bottom) {\n    x = p2.y > bottom ? NaN : interpolateX(bottom, {\n      x,\n      y\n    }, p2);\n    y = bottom;\n  }\n\n  return {\n    x,\n    y\n  };\n}\n\nfunction limitLineToArea(p1, p2, area) {\n  const {\n    x,\n    y\n  } = limitPointToArea(p1, p2, area);\n  const {\n    x: x2,\n    y: y2\n  } = limitPointToArea(p2, p1, area);\n  return {\n    x,\n    y,\n    x2,\n    y2,\n    width: Math.abs(x2 - x),\n    height: Math.abs(y2 - y)\n  };\n}\n\nclass LineAnnotation extends Element {\n  intersects(x, y, epsilon = 0.001) {\n    // Adapted from https://stackoverflow.com/a/6853926/25507\n    const sqr = v => v * v;\n\n    const {\n      x: x1,\n      y: y1,\n      x2,\n      y2\n    } = this;\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const lenSq = sqr(dx) + sqr(dy);\n    const t = lenSq === 0 ? -1 : ((x - x1) * dx + (y - y1) * dy) / lenSq;\n    let xx, yy;\n\n    if (t < 0) {\n      xx = x1;\n      yy = y1;\n    } else if (t > 1) {\n      xx = x2;\n      yy = y2;\n    } else {\n      xx = x1 + t * dx;\n      yy = y1 + t * dy;\n    }\n\n    return sqr(x - xx) + sqr(y - yy) < epsilon;\n  }\n\n  labelIsVisible() {\n    const label = this.options.label;\n    return label && label.enabled && label.content;\n  }\n\n  isOnLabel(mouseX, mouseY) {\n    const {\n      labelRect\n    } = this;\n\n    if (!labelRect || !this.labelIsVisible()) {\n      return false;\n    }\n\n    const {\n      x,\n      y\n    } = rotated({\n      x: mouseX,\n      y: mouseY\n    }, labelRect, -labelRect.rotation);\n    const w2 = labelRect.width / 2;\n    const h2 = labelRect.height / 2;\n    return x >= labelRect.x - w2 && x <= labelRect.x + w2 && y >= labelRect.y - h2 && y <= labelRect.y + h2;\n  }\n\n  inRange(x, y) {\n    const epsilon = this.options.borderWidth || 1;\n    return this.intersects(x, y, epsilon) || this.isOnLabel(x, y);\n  }\n\n  getCenterPoint() {\n    return {\n      x: (this.x2 + this.x) / 2,\n      y: (this.y2 + this.y) / 2\n    };\n  }\n\n  draw(ctx) {\n    const {\n      x,\n      y,\n      x2,\n      y2,\n      options\n    } = this;\n    ctx.save();\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset; // Draw\n\n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  drawLabel(ctx, chartArea) {\n    if (this.labelIsVisible()) {\n      ctx.save();\n      drawLabel(ctx, this, chartArea);\n      ctx.restore();\n    }\n  }\n\n  resolveElementProperties(chart, options) {\n    const scale = chart.scales[options.scaleID];\n    let {\n      top: y,\n      left: x,\n      bottom: y2,\n      right: x2\n    } = chart.chartArea;\n    let min, max;\n\n    if (scale) {\n      min = scaleValue(scale, options.value, NaN);\n      max = scaleValue(scale, options.endValue, min);\n\n      if (scale.isHorizontal()) {\n        x = min;\n        x2 = max;\n      } else {\n        y = min;\n        y2 = max;\n      }\n    } else {\n      const xScale = chart.scales[options.xScaleID];\n      const yScale = chart.scales[options.yScaleID];\n\n      if (xScale) {\n        x = scaleValue(xScale, options.xMin, x);\n        x2 = scaleValue(xScale, options.xMax, x2);\n      }\n\n      if (yScale) {\n        y = scaleValue(yScale, options.yMin, y);\n        y2 = scaleValue(yScale, options.yMax, y2);\n      }\n    }\n\n    return limitLineToArea({\n      x,\n      y\n    }, {\n      x: x2,\n      y: y2\n    }, chart.chartArea);\n  }\n\n}\n\nLineAnnotation.id = 'lineAnnotation';\nLineAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderWidth: 2,\n  borderDash: [],\n  borderDashOffset: 0,\n  label: {\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    drawTime: undefined,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: 'bold',\n      weight: undefined\n    },\n    color: '#fff',\n    xPadding: 6,\n    yPadding: 6,\n    rotation: 0,\n    cornerRadius: 6,\n    position: 'center',\n    xAdjust: 0,\n    yAdjust: 0,\n    textAlign: 'center',\n    enabled: false,\n    content: null\n  },\n  value: undefined,\n  endValue: undefined,\n  scaleID: undefined,\n  xScaleID: 'x',\n  xMin: undefined,\n  xMax: undefined,\n  yScaleID: 'y',\n  yMin: undefined,\n  yMax: undefined\n};\nLineAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\n\nfunction calculateAutoRotation(line) {\n  const {\n    x,\n    y,\n    x2,\n    y2\n  } = line;\n  const rotation = Math.atan2(y2 - y, x2 - x); // Flip the rotation if it goes > PI/2 or < -PI/2, so label stays upright\n\n  return rotation > PI / 2 ? rotation - PI : rotation < PI / -2 ? rotation + PI : rotation;\n}\n\nfunction drawLabel(ctx, line, chartArea) {\n  const label = line.options.label;\n  ctx.font = toFontString(label.font);\n  const {\n    width,\n    height\n  } = measureLabel(ctx, label);\n  const rect = line.labelRect = calculateLabelPosition(line, width, height, chartArea);\n  ctx.translate(rect.x, rect.y);\n  ctx.rotate(rect.rotation);\n  ctx.fillStyle = label.backgroundColor;\n  roundedRect(ctx, -(width / 2), -(height / 2), width, height, label.cornerRadius);\n  ctx.fill();\n  ctx.fillStyle = label.color;\n\n  if (isArray(label.content)) {\n    ctx.textAlign = label.textAlign;\n    const x = calculateLabelXAlignment(label, width);\n    let textYPosition = -(height / 2) + label.yPadding;\n\n    for (let i = 0; i < label.content.length; i++) {\n      ctx.textBaseline = 'top';\n      ctx.fillText(label.content[i], x, textYPosition);\n      textYPosition += label.font.size + label.yPadding;\n    }\n  } else if (label.content instanceof Image) {\n    const x = -(width / 2) + label.xPadding;\n    const y = -(height / 2) + label.yPadding;\n    ctx.drawImage(label.content, x, y, width - 2 * label.xPadding, height - 2 * label.yPadding);\n  } else {\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(label.content, 0, 0);\n  }\n}\n\nfunction calculateLabelXAlignment(label, width) {\n  const {\n    textAlign,\n    xPadding\n  } = label;\n\n  if (textAlign === 'start') {\n    return -(width / 2) + xPadding;\n  } else if (textAlign === 'end') {\n    return +(width / 2) - xPadding;\n  }\n\n  return 0;\n}\n\nfunction getImageSize(size, value) {\n  if (typeof value === 'number') {\n    return value;\n  } else if (typeof value === 'string') {\n    return toPercent(value) * size;\n  }\n\n  return size;\n}\n\nconst widthCache = new Map();\n\nfunction measureLabel(ctx, label) {\n  const content = label.content;\n\n  if (content instanceof Image) {\n    return {\n      width: getImageSize(content.width, label.width) + 2 * label.xPadding,\n      height: getImageSize(content.height, label.height) + 2 * label.yPadding\n    };\n  }\n\n  const lines = isArray(content) ? content : [content];\n  const count = lines.length;\n  let width = 0;\n\n  for (let i = 0; i < count; i++) {\n    const text = lines[i];\n\n    if (!widthCache.has(text)) {\n      widthCache.set(text, ctx.measureText(text).width);\n    }\n\n    width = Math.max(width, widthCache.get(text));\n  }\n\n  width += 2 * label.xPadding;\n  return {\n    width,\n    height: count * label.font.size + (count + 1) * label.yPadding\n  };\n}\n\nfunction calculateLabelPosition(line, width, height, chartArea) {\n  const label = line.options.label;\n  const {\n    xAdjust,\n    yAdjust,\n    xPadding,\n    yPadding,\n    position\n  } = label;\n  const p1 = {\n    x: line.x,\n    y: line.y\n  };\n  const p2 = {\n    x: line.x2,\n    y: line.y2\n  };\n  const rotation = label.rotation === 'auto' ? calculateAutoRotation(line) : toRadians(label.rotation);\n  const size = rotatedSize(width, height, rotation);\n  const t = calculateT(line, position, size, chartArea);\n  const pt = pointInLine(p1, p2, t);\n  const xCoordinateSizes = {\n    size: size.w,\n    min: chartArea.left,\n    max: chartArea.right,\n    padding: xPadding\n  };\n  const yCoordinateSizes = {\n    size: size.h,\n    min: chartArea.top,\n    max: chartArea.bottom,\n    padding: yPadding\n  };\n  return {\n    x: adjustLabelCoordinate(pt.x, xCoordinateSizes) + xAdjust,\n    y: adjustLabelCoordinate(pt.y, yCoordinateSizes) + yAdjust,\n    width,\n    height,\n    rotation\n  };\n}\n\nfunction rotatedSize(width, height, rotation) {\n  const cos = Math.cos(rotation);\n  const sin = Math.sin(rotation);\n  return {\n    w: Math.abs(width * cos) + Math.abs(height * sin),\n    h: Math.abs(width * sin) + Math.abs(height * cos)\n  };\n}\n\nfunction calculateT(line, position, rotSize, chartArea) {\n  let t = 0.5;\n  const space = spaceAround(line, chartArea);\n  const label = line.options.label;\n\n  if (position === 'start') {\n    t = calculateTAdjust({\n      w: line.x2 - line.x,\n      h: line.y2 - line.y\n    }, rotSize, label, space);\n  } else if (position === 'end') {\n    t = 1 - calculateTAdjust({\n      w: line.x - line.x2,\n      h: line.y - line.y2\n    }, rotSize, label, space);\n  }\n\n  return t;\n}\n\nfunction calculateTAdjust(lineSize, labelSize, label, space) {\n  const {\n    xPadding,\n    yPadding\n  } = label;\n  const lineW = lineSize.w * space.dx;\n  const lineH = lineSize.h * space.dy;\n  const x = lineW > 0 && (labelSize.w / 2 + xPadding - space.x) / lineW;\n  const y = lineH > 0 && (labelSize.h / 2 + yPadding - space.y) / lineH;\n  return clamp(Math.max(x, y), 0, 0.25);\n}\n\nfunction spaceAround(line, chartArea) {\n  const {\n    x,\n    x2,\n    y,\n    y2\n  } = line;\n  const t = Math.min(y, y2) - chartArea.top;\n  const l = Math.min(x, x2) - chartArea.left;\n  const b = chartArea.bottom - Math.max(y, y2);\n  const r = chartArea.right - Math.max(x, x2);\n  return {\n    x: Math.min(l, r),\n    y: Math.min(t, b),\n    dx: l < r ? 1 : -1,\n    dy: t < b ? 1 : -1\n  };\n}\n\nfunction adjustLabelCoordinate(coordinate, labelSizes) {\n  const {\n    size,\n    min,\n    max,\n    padding\n  } = labelSizes;\n  const halfSize = size / 2;\n\n  if (size > max - min) {\n    // if it does not fit, display as much as possible\n    return (max + min) / 2;\n  }\n\n  if (min >= coordinate - padding - halfSize) {\n    coordinate = min + padding + halfSize;\n  }\n\n  if (max <= coordinate + padding + halfSize) {\n    coordinate = max - padding - halfSize;\n  }\n\n  return coordinate;\n}\n\nclass EllipseAnnotation extends BoxAnnotation {\n  inRange(x, y) {\n    return pointInEllipse({\n      x,\n      y\n    }, this);\n  }\n\n  draw(ctx) {\n    const {\n      width,\n      height,\n      options\n    } = this;\n    const center = this.getCenterPoint();\n    ctx.save();\n    ctx.beginPath();\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.fillStyle = options.backgroundColor;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n    ctx.ellipse(center.x, center.y, height / 2, width / 2, Math.PI / 2, 0, 2 * Math.PI);\n    ctx.fill();\n    ctx.stroke();\n    ctx.restore();\n  }\n\n}\n\nEllipseAnnotation.id = 'ellipseAnnotation';\nEllipseAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderDash: [],\n  borderDashOffset: 0,\n  borderWidth: 1,\n  xScaleID: 'x',\n  xMin: undefined,\n  xMax: undefined,\n  yScaleID: 'y',\n  yMin: undefined,\n  yMax: undefined\n};\nEllipseAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nfunction pointInEllipse(p, ellipse) {\n  const {\n    width,\n    height\n  } = ellipse;\n  const center = ellipse.getCenterPoint(true);\n  const xRadius = width / 2;\n  const yRadius = height / 2;\n\n  if (xRadius <= 0 || yRadius <= 0) {\n    return false;\n  }\n\n  return Math.pow(p.x - center.x, 2) / Math.pow(xRadius, 2) + Math.pow(p.y - center.y, 2) / Math.pow(yRadius, 2) <= 1.0;\n}\n\nclass PointAnnotation extends Element {\n  inRange(x, y) {\n    const {\n      width,\n      options\n    } = this;\n    const center = this.getCenterPoint(true);\n    const radius = width / 2 + options.borderWidth;\n\n    if (radius <= 0) {\n      return false;\n    }\n\n    return Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2) <= Math.pow(radius, 2);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {\n      x,\n      y\n    } = this.getProps(['x', 'y'], useFinalPosition);\n    return {\n      x,\n      y\n    };\n  }\n\n  draw(ctx) {\n    const {\n      x,\n      y,\n      width,\n      options\n    } = this;\n    ctx.save();\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.fillStyle = options.backgroundColor;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n    ctx.beginPath();\n    ctx.arc(x, y, width / 2, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    const {\n      chartArea,\n      scales\n    } = chart;\n    const xScale = scales[options.xScaleID];\n    const yScale = scales[options.yScaleID];\n    let x = chartArea.width / 2;\n    let y = chartArea.height / 2;\n\n    if (xScale) {\n      x = scaleValue(xScale, options.xValue, x);\n    }\n\n    if (yScale) {\n      y = scaleValue(yScale, options.yValue, y);\n    }\n\n    return {\n      x,\n      y,\n      width: options.radius * 2,\n      height: options.radius * 2\n    };\n  }\n\n}\n\nPointAnnotation.id = 'pointAnnotation';\nPointAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderDash: [],\n  borderDashOffset: 0,\n  borderWidth: 1,\n  radius: 10,\n  xScaleID: 'x',\n  xValue: undefined,\n  yScaleID: 'y',\n  yValue: undefined\n};\nPointAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nvar version = \"1.0.2\";\nconst chartStates = new Map();\nconst annotationTypes = {\n  box: BoxAnnotation,\n  line: LineAnnotation,\n  ellipse: EllipseAnnotation,\n  point: PointAnnotation\n};\nObject.keys(annotationTypes).forEach(key => {\n  defaults.describe(`elements.${annotationTypes[key].id}`, {\n    _fallback: 'plugins.annotation'\n  });\n});\nvar annotation = {\n  id: 'annotation',\n  version,\n\n  afterRegister() {\n    Chart.register(annotationTypes);\n  },\n\n  afterUnregister() {\n    Chart.unregister(annotationTypes);\n  },\n\n  beforeInit(chart) {\n    chartStates.set(chart, {\n      annotations: [],\n      elements: [],\n      listeners: {},\n      listened: false,\n      moveListened: false\n    });\n  },\n\n  beforeUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    const annotations = state.annotations = [];\n    let annotationOptions = options.annotations;\n\n    if (isObject(annotationOptions)) {\n      Object.keys(annotationOptions).forEach(key => {\n        const value = annotationOptions[key];\n\n        if (isObject(value)) {\n          value.id = key;\n          annotations.push(value);\n        }\n      });\n    } else if (isArray(annotationOptions)) {\n      annotations.push(...annotationOptions);\n    }\n  },\n\n  afterDataLimits(chart, args) {\n    const state = chartStates.get(chart);\n    adjustScaleRange(chart, args.scale, state.annotations.filter(a => a.display && a.adjustScaleRange));\n  },\n\n  afterUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    updateListeners(chart, state, options);\n    updateElements(chart, state, options, args.mode);\n  },\n\n  beforeDatasetsDraw(chart) {\n    draw(chart, 'beforeDatasetsDraw');\n  },\n\n  afterDatasetsDraw(chart) {\n    draw(chart, 'afterDatasetsDraw');\n  },\n\n  beforeDraw(chart) {\n    draw(chart, 'beforeDraw');\n  },\n\n  afterDraw(chart) {\n    draw(chart, 'afterDraw');\n  },\n\n  beforeEvent(chart, args, options) {\n    const state = chartStates.get(chart);\n    handleEvent(chart, state, args.event, options);\n  },\n\n  destroy(chart) {\n    chartStates.delete(chart);\n  },\n\n  _getState(chart) {\n    return chartStates.get(chart);\n  },\n\n  defaults: {\n    drawTime: 'afterDatasetsDraw',\n    dblClickSpeed: 350,\n    // ms\n    animations: {\n      numbers: {\n        properties: ['x', 'y', 'x2', 'y2', 'width', 'height'],\n        type: 'number'\n      }\n    },\n    label: {\n      drawTime: null\n    }\n  },\n  descriptors: {\n    _indexable: false,\n    _scriptable: prop => !hooks.includes(prop),\n    annotations: {\n      _allKeys: false,\n      _fallback: (prop, opts) => `elements.${annotationTypes[opts.type || 'line'].id}`\n    }\n  },\n  additionalOptionScopes: ['']\n};\nconst directUpdater = {\n  update: Object.assign\n};\n\nfunction resolveAnimations(chart, animOpts, mode) {\n  if (mode === 'reset' || mode === 'none' || mode === 'resize') {\n    return directUpdater;\n  }\n\n  return new Animations(chart, animOpts);\n}\n\nfunction updateElements(chart, state, options, mode) {\n  const animations = resolveAnimations(chart, options.animations, mode);\n  const annotations = state.annotations;\n  const elements = resyncElements(state.elements, annotations);\n\n  for (let i = 0; i < annotations.length; i++) {\n    const annotation = annotations[i];\n    let el = elements[i];\n    const elType = annotationTypes[annotation.type] || annotationTypes.line;\n\n    if (!el || !(el instanceof elType)) {\n      el = elements[i] = new elType();\n    }\n\n    const opts = resolveAnnotationOptions(annotation.setContext(getContext(chart, el, annotation)));\n    const properties = el.resolveElementProperties(chart, opts);\n    properties.skip = isNaN(properties.x) || isNaN(properties.y);\n    properties.options = opts;\n    animations.update(el, properties);\n  }\n}\n\nfunction resolveAnnotationOptions(resolver) {\n  const elType = annotationTypes[resolver.type] || annotationTypes.line;\n  const result = {};\n  result.id = resolver.id;\n  result.type = resolver.type;\n  result.drawTime = resolver.drawTime;\n  Object.assign(result, resolveObj(resolver, elType.defaults), resolveObj(resolver, elType.defaultRoutes));\n\n  for (const hook of hooks) {\n    result[hook] = resolver[hook];\n  }\n\n  return result;\n}\n\nfunction resolveObj(resolver, defs) {\n  const result = {};\n\n  for (const name of Object.keys(defs)) {\n    const optDefs = defs[name];\n    const value = resolver[name];\n    result[name] = isObject(optDefs) ? resolveObj(value, optDefs) : value;\n  }\n\n  return result;\n}\n\nfunction getContext(chart, element, annotation) {\n  return element.$context || (element.$context = Object.assign(Object.create(chart.getContext()), {\n    element,\n    id: annotation.id,\n    type: 'annotation'\n  }));\n}\n\nfunction resyncElements(elements, annotations) {\n  const count = annotations.length;\n  const start = elements.length;\n\n  if (start < count) {\n    const add = count - start;\n    elements.splice(start, 0, ...new Array(add));\n  } else if (start > count) {\n    elements.splice(count, start - count);\n  }\n\n  return elements;\n}\n\nfunction draw(chart, caller) {\n  const {\n    ctx,\n    chartArea\n  } = chart;\n  const state = chartStates.get(chart);\n  const elements = state.elements.filter(el => !el.skip && el.options.display);\n  clipArea(ctx, chartArea);\n  elements.forEach(el => {\n    if (el.options.drawTime === caller) {\n      el.draw(ctx);\n    }\n  });\n  unclipArea(ctx);\n  elements.forEach(el => {\n    if ('drawLabel' in el && el.options.label && (el.options.label.drawTime || el.options.drawTime) === caller) {\n      el.drawLabel(ctx, chartArea);\n    }\n  });\n}\n\nfunction adjustScaleRange(chart, scale, annotations) {\n  const range = getScaleLimits(scale, annotations);\n  let changed = false;\n\n  if (isFinite(range.min) && typeof scale.options.min === 'undefined' && typeof scale.options.suggestedMin === 'undefined') {\n    changed = scale.min !== range.min;\n    scale.min = range.min;\n  }\n\n  if (isFinite(range.max) && typeof scale.options.max === 'undefined' && typeof scale.options.suggestedMax === 'undefined') {\n    changed = scale.max !== range.max;\n    scale.max = range.max;\n  }\n\n  if (changed && typeof scale.handleTickRangeOptions === 'function') {\n    scale.handleTickRangeOptions();\n  }\n}\n\nfunction getScaleLimits(scale, annotations) {\n  const axis = scale.axis;\n  const scaleID = scale.id;\n  const scaleIDOption = axis + 'ScaleID';\n  let min = valueOrDefault(scale.min, Number.NEGATIVE_INFINITY);\n  let max = valueOrDefault(scale.max, Number.POSITIVE_INFINITY);\n\n  for (const annotation of annotations) {\n    if (annotation.scaleID === scaleID) {\n      for (const prop of ['value', 'endValue']) {\n        const raw = annotation[prop];\n\n        if (raw) {\n          const value = scale.parse(raw);\n          min = Math.min(min, value);\n          max = Math.max(max, value);\n        }\n      }\n    } else if (annotation[scaleIDOption] === scaleID) {\n      for (const prop of [axis + 'Min', axis + 'Max', axis + 'Value']) {\n        const raw = annotation[prop];\n\n        if (raw) {\n          const value = scale.parse(raw);\n          min = Math.min(min, value);\n          max = Math.max(max, value);\n        }\n      }\n    }\n  }\n\n  return {\n    min,\n    max\n  };\n}\n\nexport default annotation;","map":{"version":3,"sources":["C:/Users/narut/Documents/Coding/stock-calc/node_modules/chartjs-plugin-annotation/dist/chartjs-plugin-annotation.esm.js"],"names":["Element","Chart","defaults","Animations","distanceBetweenPoints","callback","isFinite","toFontString","isArray","toRadians","isObject","clipArea","unclipArea","valueOrDefault","clickHooks","moveHooks","hooks","concat","updateListeners","chart","state","options","annotations","listened","moveListened","forEach","hook","listeners","scope","handleEvent","event","type","handleMoveEvents","handleClickEvents","element","getNearestItem","elements","previous","hovered","dispatchMoveEvents","dispatchEvent","leave","enter","elOpts","dblclick","click","clickTimeout","clearTimeout","setTimeout","dblClickSpeed","_state","handler","position","minDistance","Number","POSITIVE_INFINITY","filter","display","inRange","x","y","reduce","nearestItems","center","getCenterPoint","distance","push","sort","a","b","_index","slice","PI$1","Math","PI","HALF_PI","scaleValue","scale","value","fallback","parse","getPixelForValue","roundedRect","ctx","width","height","radius","beginPath","r","min","left","top","right","bottom","moveTo","arc","closePath","rect","rotated","point","angle","cos","sin","cx","cy","BoxAnnotation","mouseX","mouseY","useFinalPosition","getProps","draw","save","lineWidth","borderWidth","strokeStyle","borderColor","fillStyle","backgroundColor","setLineDash","borderDash","lineDashOffset","borderDashOffset","cornerRadius","fill","stroke","restore","resolveElementProperties","xScale","scales","xScaleID","yScale","yScaleID","y2","x2","chartArea","max","xMin","xMax","yMin","yMax","id","adjustScaleRange","undefined","defaultRoutes","clamp","from","to","pointInLine","p1","p2","t","interpolateX","abs","interpolateY","toPercent","s","endsWith","parseFloat","limitPointToArea","NaN","limitLineToArea","area","LineAnnotation","intersects","epsilon","sqr","v","x1","y1","dx","dy","lenSq","xx","yy","labelIsVisible","label","enabled","content","isOnLabel","labelRect","rotation","w2","h2","lineTo","drawLabel","scaleID","endValue","isHorizontal","drawTime","font","family","lineHeight","size","style","weight","color","xPadding","yPadding","xAdjust","yAdjust","textAlign","calculateAutoRotation","line","atan2","measureLabel","calculateLabelPosition","translate","rotate","calculateLabelXAlignment","textYPosition","i","length","textBaseline","fillText","Image","drawImage","getImageSize","widthCache","Map","lines","count","text","has","set","measureText","get","rotatedSize","calculateT","pt","xCoordinateSizes","w","padding","yCoordinateSizes","h","adjustLabelCoordinate","rotSize","space","spaceAround","calculateTAdjust","lineSize","labelSize","lineW","lineH","l","coordinate","labelSizes","halfSize","EllipseAnnotation","pointInEllipse","ellipse","p","xRadius","yRadius","pow","PointAnnotation","xValue","yValue","version","chartStates","annotationTypes","box","Object","keys","key","describe","_fallback","annotation","afterRegister","register","afterUnregister","unregister","beforeInit","beforeUpdate","args","annotationOptions","afterDataLimits","afterUpdate","updateElements","mode","beforeDatasetsDraw","afterDatasetsDraw","beforeDraw","afterDraw","beforeEvent","destroy","delete","_getState","animations","numbers","properties","descriptors","_indexable","_scriptable","prop","includes","_allKeys","opts","additionalOptionScopes","directUpdater","update","assign","resolveAnimations","animOpts","resyncElements","el","elType","resolveAnnotationOptions","setContext","getContext","skip","isNaN","resolver","result","resolveObj","defs","name","optDefs","$context","create","start","add","splice","Array","caller","range","getScaleLimits","changed","suggestedMin","suggestedMax","handleTickRangeOptions","axis","scaleIDOption","NEGATIVE_INFINITY","raw"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,OAAT,EAAkBC,KAAlB,EAAyBC,QAAzB,EAAmCC,UAAnC,QAAqD,UAArD;AACA,SAASC,qBAAT,EAAgCC,QAAhC,EAA0CC,QAA1C,EAAoDC,YAApD,EAAkEC,OAAlE,EAA2EC,SAA3E,EAAsFC,QAAtF,EAAgGC,QAAhG,EAA0GC,UAA1G,EAAsHC,cAAtH,QAA4I,kBAA5I;AAEA,MAAMC,UAAU,GAAG,CAAC,OAAD,EAAU,UAAV,CAAnB;AACA,MAAMC,SAAS,GAAG,CAAC,OAAD,EAAU,OAAV,CAAlB;AACA,MAAMC,KAAK,GAAGF,UAAU,CAACG,MAAX,CAAkBF,SAAlB,CAAd;;AAEA,SAASG,eAAT,CAAyBC,KAAzB,EAAgCC,KAAhC,EAAuCC,OAAvC,EAAgD;AAC9C,QAAMC,WAAW,GAAGF,KAAK,CAACE,WAAN,IAAqB,EAAzC;AACAF,EAAAA,KAAK,CAACG,QAAN,GAAiB,KAAjB;AACAH,EAAAA,KAAK,CAACI,YAAN,GAAqB,KAArB;AAEAR,EAAAA,KAAK,CAACS,OAAN,CAAcC,IAAI,IAAI;AACpB,QAAI,OAAOL,OAAO,CAACK,IAAD,CAAd,KAAyB,UAA7B,EAAyC;AACvCN,MAAAA,KAAK,CAACG,QAAN,GAAiB,IAAjB;AACAH,MAAAA,KAAK,CAACO,SAAN,CAAgBD,IAAhB,IAAwBL,OAAO,CAACK,IAAD,CAA/B;AACD;AACF,GALD;AAMAX,EAAAA,SAAS,CAACU,OAAV,CAAkBC,IAAI,IAAI;AACxB,QAAI,OAAOL,OAAO,CAACK,IAAD,CAAd,KAAyB,UAA7B,EAAyC;AACvCN,MAAAA,KAAK,CAACI,YAAN,GAAqB,IAArB;AACD;AACF,GAJD;;AAMA,MAAI,CAACJ,KAAK,CAACG,QAAP,IAAmB,CAACH,KAAK,CAACI,YAA9B,EAA4C;AAC1CF,IAAAA,WAAW,CAACG,OAAZ,CAAoBG,KAAK,IAAI;AAC3B,UAAI,CAACR,KAAK,CAACG,QAAX,EAAqB;AACnBT,QAAAA,UAAU,CAACW,OAAX,CAAmBC,IAAI,IAAI;AACzB,cAAI,OAAOE,KAAK,CAACF,IAAD,CAAZ,KAAuB,UAA3B,EAAuC;AACrCN,YAAAA,KAAK,CAACG,QAAN,GAAiB,IAAjB;AACD;AACF,SAJD;AAKD;;AACD,UAAI,CAACH,KAAK,CAACI,YAAX,EAAyB;AACvBT,QAAAA,SAAS,CAACU,OAAV,CAAkBC,IAAI,IAAI;AACxB,cAAI,OAAOE,KAAK,CAACF,IAAD,CAAZ,KAAuB,UAA3B,EAAuC;AACrCN,YAAAA,KAAK,CAACG,QAAN,GAAiB,IAAjB;AACAH,YAAAA,KAAK,CAACI,YAAN,GAAqB,IAArB;AACD;AACF,SALD;AAMD;AACF,KAhBD;AAiBD;AACF;;AAED,SAASK,WAAT,CAAqBV,KAArB,EAA4BC,KAA5B,EAAmCU,KAAnC,EAA0CT,OAA1C,EAAmD;AACjD,MAAID,KAAK,CAACG,QAAV,EAAoB;AAClB,YAAQO,KAAK,CAACC,IAAd;AACA,WAAK,WAAL;AACA,WAAK,UAAL;AACEC,QAAAA,gBAAgB,CAACb,KAAD,EAAQC,KAAR,EAAeU,KAAf,CAAhB;AACA;;AACF,WAAK,OAAL;AACEG,QAAAA,iBAAiB,CAACd,KAAD,EAAQC,KAAR,EAAeU,KAAf,EAAsBT,OAAtB,CAAjB;AACA;AAPF;AASD;AACF;;AAED,SAASW,gBAAT,CAA0Bb,KAA1B,EAAiCC,KAAjC,EAAwCU,KAAxC,EAA+C;AAC7C,MAAI,CAACV,KAAK,CAACI,YAAX,EAAyB;AACvB;AACD;;AAED,MAAIU,OAAJ;;AAEA,MAAIJ,KAAK,CAACC,IAAN,KAAe,WAAnB,EAAgC;AAC9BG,IAAAA,OAAO,GAAGC,cAAc,CAACf,KAAK,CAACgB,QAAP,EAAiBN,KAAjB,CAAxB;AACD;;AAED,QAAMO,QAAQ,GAAGjB,KAAK,CAACkB,OAAvB;AACAlB,EAAAA,KAAK,CAACkB,OAAN,GAAgBJ,OAAhB;AAEAK,EAAAA,kBAAkB,CAACpB,KAAD,EAAQC,KAAR,EAAeiB,QAAf,EAAyBH,OAAzB,CAAlB;AACD;;AAED,SAASK,kBAAT,CAA4BpB,KAA5B,EAAmCC,KAAnC,EAA0CiB,QAA1C,EAAoDH,OAApD,EAA6D;AAC3D,MAAIG,QAAQ,IAAIA,QAAQ,KAAKH,OAA7B,EAAsC;AACpCM,IAAAA,aAAa,CAACrB,KAAD,EAAQC,KAAR,EAAeiB,QAAQ,CAAChB,OAAT,CAAiBoB,KAAjB,IAA0BrB,KAAK,CAACO,SAAN,CAAgBc,KAAzD,EAAgEJ,QAAhE,CAAb;AACD;;AACD,MAAIH,OAAO,IAAIA,OAAO,KAAKG,QAA3B,EAAqC;AACnCG,IAAAA,aAAa,CAACrB,KAAD,EAAQC,KAAR,EAAec,OAAO,CAACb,OAAR,CAAgBqB,KAAhB,IAAyBtB,KAAK,CAACO,SAAN,CAAgBe,KAAxD,EAA+DR,OAA/D,CAAb;AACD;AACF;;AAED,SAASD,iBAAT,CAA2Bd,KAA3B,EAAkCC,KAAlC,EAAyCU,KAAzC,EAAgDT,OAAhD,EAAyD;AACvD,QAAMM,SAAS,GAAGP,KAAK,CAACO,SAAxB;AACA,QAAMO,OAAO,GAAGC,cAAc,CAACf,KAAK,CAACgB,QAAP,EAAiBN,KAAjB,CAA9B;;AACA,MAAII,OAAJ,EAAa;AACX,UAAMS,MAAM,GAAGT,OAAO,CAACb,OAAvB;AACA,UAAMuB,QAAQ,GAAGD,MAAM,CAACC,QAAP,IAAmBjB,SAAS,CAACiB,QAA9C;AACA,UAAMC,KAAK,GAAGF,MAAM,CAACE,KAAP,IAAgBlB,SAAS,CAACkB,KAAxC;;AACA,QAAIX,OAAO,CAACY,YAAZ,EAA0B;AACxB;AACAC,MAAAA,YAAY,CAACb,OAAO,CAACY,YAAT,CAAZ;AACA,aAAOZ,OAAO,CAACY,YAAf;AACAN,MAAAA,aAAa,CAACrB,KAAD,EAAQC,KAAR,EAAewB,QAAf,EAAyBV,OAAzB,CAAb;AACD,KALD,MAKO,IAAIU,QAAJ,EAAc;AACnB;AACAV,MAAAA,OAAO,CAACY,YAAR,GAAuBE,UAAU,CAAC,MAAM;AACtC,eAAOd,OAAO,CAACY,YAAf;AACAN,QAAAA,aAAa,CAACrB,KAAD,EAAQC,KAAR,EAAeyB,KAAf,EAAsBX,OAAtB,CAAb;AACD,OAHgC,EAG9Bb,OAAO,CAAC4B,aAHsB,CAAjC;AAID,KANM,MAMA;AACL;AACAT,MAAAA,aAAa,CAACrB,KAAD,EAAQC,KAAR,EAAeyB,KAAf,EAAsBX,OAAtB,CAAb;AACD;AACF;AACF;;AAED,SAASM,aAAT,CAAuBrB,KAAvB,EAA8B+B,MAA9B,EAAsCC,OAAtC,EAA+CjB,OAA/C,EAAwD;AACtD7B,EAAAA,QAAQ,CAAC8C,OAAD,EAAU,CAAC;AAAChC,IAAAA,KAAD;AAAQe,IAAAA;AAAR,GAAD,CAAV,CAAR;AACD;;AAED,SAASC,cAAT,CAAwBC,QAAxB,EAAkCgB,QAAlC,EAA4C;AAC1C,MAAIC,WAAW,GAAGC,MAAM,CAACC,iBAAzB;AAEA,SAAOnB,QAAQ,CACZoB,MADI,CACItB,OAAD,IAAaA,OAAO,CAACb,OAAR,CAAgBoC,OAAhB,IAA2BvB,OAAO,CAACwB,OAAR,CAAgBN,QAAQ,CAACO,CAAzB,EAA4BP,QAAQ,CAACQ,CAArC,CAD3C,EAEJC,MAFI,CAEG,CAACC,YAAD,EAAe5B,OAAf,KAA2B;AACjC,UAAM6B,MAAM,GAAG7B,OAAO,CAAC8B,cAAR,EAAf;AACA,UAAMC,QAAQ,GAAG7D,qBAAqB,CAACgD,QAAD,EAAWW,MAAX,CAAtC;;AAEA,QAAIE,QAAQ,GAAGZ,WAAf,EAA4B;AAC1BS,MAAAA,YAAY,GAAG,CAAC5B,OAAD,CAAf;AACAmB,MAAAA,WAAW,GAAGY,QAAd;AACD,KAHD,MAGO,IAAIA,QAAQ,KAAKZ,WAAjB,EAA8B;AACnC;AACAS,MAAAA,YAAY,CAACI,IAAb,CAAkBhC,OAAlB;AACD;;AAED,WAAO4B,YAAP;AACD,GAfI,EAeF,EAfE,EAgBJK,IAhBI,CAgBC,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACE,MAAF,GAAWD,CAAC,CAACC,MAhBxB,EAiBJC,KAjBI,CAiBE,CAjBF,EAiBK,CAjBL,EAiBQ,CAjBR,CAAP,CAH0C,CAoBvB;AACpB;;AAED,MAAMC,IAAI,GAAGC,IAAI,CAACC,EAAlB;AACA,MAAMC,OAAO,GAAGH,IAAI,GAAG,CAAvB;;AAEA,SAASI,UAAT,CAAoBC,KAApB,EAA2BC,KAA3B,EAAkCC,QAAlC,EAA4C;AAC1CD,EAAAA,KAAK,GAAG,OAAOA,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoCD,KAAK,CAACG,KAAN,CAAYF,KAAZ,CAA5C;AACA,SAAOxE,QAAQ,CAACwE,KAAD,CAAR,GAAkBD,KAAK,CAACI,gBAAN,CAAuBH,KAAvB,CAAlB,GAAkDC,QAAzD;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,WAAT,CAAqBC,GAArB,EAA0BxB,CAA1B,EAA6BC,CAA7B,EAAgCwB,KAAhC,EAAuCC,MAAvC,EAA+CC,MAA/C,EAAuD;AACrDH,EAAAA,GAAG,CAACI,SAAJ;;AACA,MAAID,MAAJ,EAAY;AACV,UAAME,CAAC,GAAGf,IAAI,CAACgB,GAAL,CAASH,MAAT,EAAiBD,MAAM,GAAG,CAA1B,EAA6BD,KAAK,GAAG,CAArC,CAAV;AACA,UAAMM,IAAI,GAAG/B,CAAC,GAAG6B,CAAjB;AACA,UAAMG,GAAG,GAAG/B,CAAC,GAAG4B,CAAhB;AACA,UAAMI,KAAK,GAAGjC,CAAC,GAAGyB,KAAJ,GAAYI,CAA1B;AACA,UAAMK,MAAM,GAAGjC,CAAC,GAAGyB,MAAJ,GAAaG,CAA5B;AAEAL,IAAAA,GAAG,CAACW,MAAJ,CAAWnC,CAAX,EAAcgC,GAAd;;AACA,QAAID,IAAI,GAAGE,KAAP,IAAgBD,GAAG,GAAGE,MAA1B,EAAkC;AAChCV,MAAAA,GAAG,CAACY,GAAJ,CAAQL,IAAR,EAAcC,GAAd,EAAmBH,CAAnB,EAAsB,CAAChB,IAAvB,EAA6B,CAACG,OAA9B;AACAQ,MAAAA,GAAG,CAACY,GAAJ,CAAQH,KAAR,EAAeD,GAAf,EAAoBH,CAApB,EAAuB,CAACb,OAAxB,EAAiC,CAAjC;AACAQ,MAAAA,GAAG,CAACY,GAAJ,CAAQH,KAAR,EAAeC,MAAf,EAAuBL,CAAvB,EAA0B,CAA1B,EAA6Bb,OAA7B;AACAQ,MAAAA,GAAG,CAACY,GAAJ,CAAQL,IAAR,EAAcG,MAAd,EAAsBL,CAAtB,EAAyBb,OAAzB,EAAkCH,IAAlC;AACD,KALD,MAKO,IAAIkB,IAAI,GAAGE,KAAX,EAAkB;AACvBT,MAAAA,GAAG,CAACW,MAAJ,CAAWJ,IAAX,EAAiB9B,CAAjB;AACAuB,MAAAA,GAAG,CAACY,GAAJ,CAAQH,KAAR,EAAeD,GAAf,EAAoBH,CAApB,EAAuB,CAACb,OAAxB,EAAiCA,OAAjC;AACAQ,MAAAA,GAAG,CAACY,GAAJ,CAAQL,IAAR,EAAcC,GAAd,EAAmBH,CAAnB,EAAsBb,OAAtB,EAA+BH,IAAI,GAAGG,OAAtC;AACD,KAJM,MAIA,IAAIgB,GAAG,GAAGE,MAAV,EAAkB;AACvBV,MAAAA,GAAG,CAACY,GAAJ,CAAQL,IAAR,EAAcC,GAAd,EAAmBH,CAAnB,EAAsB,CAAChB,IAAvB,EAA6B,CAA7B;AACAW,MAAAA,GAAG,CAACY,GAAJ,CAAQL,IAAR,EAAcG,MAAd,EAAsBL,CAAtB,EAAyB,CAAzB,EAA4BhB,IAA5B;AACD,KAHM,MAGA;AACLW,MAAAA,GAAG,CAACY,GAAJ,CAAQL,IAAR,EAAcC,GAAd,EAAmBH,CAAnB,EAAsB,CAAChB,IAAvB,EAA6BA,IAA7B;AACD;;AACDW,IAAAA,GAAG,CAACa,SAAJ;AACAb,IAAAA,GAAG,CAACW,MAAJ,CAAWnC,CAAX,EAAcC,CAAd;AACD,GAzBD,MAyBO;AACLuB,IAAAA,GAAG,CAACc,IAAJ,CAAStC,CAAT,EAAYC,CAAZ,EAAewB,KAAf,EAAsBC,MAAtB;AACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASa,OAAT,CAAiBC,KAAjB,EAAwBpC,MAAxB,EAAgCqC,KAAhC,EAAuC;AACrC,MAAIC,GAAG,GAAG5B,IAAI,CAAC4B,GAAL,CAASD,KAAT,CAAV;AACA,MAAIE,GAAG,GAAG7B,IAAI,CAAC6B,GAAL,CAASF,KAAT,CAAV;AACA,MAAIG,EAAE,GAAGxC,MAAM,CAACJ,CAAhB;AACA,MAAI6C,EAAE,GAAGzC,MAAM,CAACH,CAAhB;AAEA,SAAO;AACLD,IAAAA,CAAC,EAAE4C,EAAE,GAAGF,GAAG,IAAIF,KAAK,CAACxC,CAAN,GAAU4C,EAAd,CAAR,GAA4BD,GAAG,IAAIH,KAAK,CAACvC,CAAN,GAAU4C,EAAd,CAD7B;AAEL5C,IAAAA,CAAC,EAAE4C,EAAE,GAAGF,GAAG,IAAIH,KAAK,CAACxC,CAAN,GAAU4C,EAAd,CAAR,GAA4BF,GAAG,IAAIF,KAAK,CAACvC,CAAN,GAAU4C,EAAd;AAF7B,GAAP;AAID;;AAED,MAAMC,aAAN,SAA4BzG,OAA5B,CAAoC;AAClC0D,EAAAA,OAAO,CAACgD,MAAD,EAASC,MAAT,EAAiBC,gBAAjB,EAAmC;AACxC,UAAM;AAACjD,MAAAA,CAAD;AAAIC,MAAAA,CAAJ;AAAOwB,MAAAA,KAAP;AAAcC,MAAAA;AAAd,QAAwB,KAAKwB,QAAL,CAAc,CAAC,GAAD,EAAM,GAAN,EAAW,OAAX,EAAoB,QAApB,CAAd,EAA6CD,gBAA7C,CAA9B;AAEA,WAAOF,MAAM,IAAI/C,CAAV,IACR+C,MAAM,IAAI/C,CAAC,GAAGyB,KADN,IAERuB,MAAM,IAAI/C,CAFF,IAGR+C,MAAM,IAAI/C,CAAC,GAAGyB,MAHb;AAID;;AAEDrB,EAAAA,cAAc,CAAC4C,gBAAD,EAAmB;AAC/B,UAAM;AAACjD,MAAAA,CAAD;AAAIC,MAAAA,CAAJ;AAAOwB,MAAAA,KAAP;AAAcC,MAAAA;AAAd,QAAwB,KAAKwB,QAAL,CAAc,CAAC,GAAD,EAAM,GAAN,EAAW,OAAX,EAAoB,QAApB,CAAd,EAA6CD,gBAA7C,CAA9B;AACA,WAAO;AACLjD,MAAAA,CAAC,EAAEA,CAAC,GAAGyB,KAAK,GAAG,CADV;AAELxB,MAAAA,CAAC,EAAEA,CAAC,GAAGyB,MAAM,GAAG;AAFX,KAAP;AAID;;AAEDyB,EAAAA,IAAI,CAAC3B,GAAD,EAAM;AACR,UAAM;AAACxB,MAAAA,CAAD;AAAIC,MAAAA,CAAJ;AAAOwB,MAAAA,KAAP;AAAcC,MAAAA,MAAd;AAAsBhE,MAAAA;AAAtB,QAAiC,IAAvC;AAEA8D,IAAAA,GAAG,CAAC4B,IAAJ;AAEA5B,IAAAA,GAAG,CAAC6B,SAAJ,GAAgB3F,OAAO,CAAC4F,WAAxB;AACA9B,IAAAA,GAAG,CAAC+B,WAAJ,GAAkB7F,OAAO,CAAC8F,WAA1B;AACAhC,IAAAA,GAAG,CAACiC,SAAJ,GAAgB/F,OAAO,CAACgG,eAAxB;AAEAlC,IAAAA,GAAG,CAACmC,WAAJ,CAAgBjG,OAAO,CAACkG,UAAxB;AACApC,IAAAA,GAAG,CAACqC,cAAJ,GAAqBnG,OAAO,CAACoG,gBAA7B;AAEAvC,IAAAA,WAAW,CAACC,GAAD,EAAMxB,CAAN,EAASC,CAAT,EAAYwB,KAAZ,EAAmBC,MAAnB,EAA2BhE,OAAO,CAACqG,YAAnC,CAAX;AACAvC,IAAAA,GAAG,CAACwC,IAAJ,GAbQ,CAeR;;AACA,QAAItG,OAAO,CAAC4F,WAAZ,EAAyB;AACvB9B,MAAAA,GAAG,CAACyC,MAAJ;AACD;;AAEDzC,IAAAA,GAAG,CAAC0C,OAAJ;AACD;;AAEDC,EAAAA,wBAAwB,CAAC3G,KAAD,EAAQE,OAAR,EAAiB;AACvC,UAAM0G,MAAM,GAAG5G,KAAK,CAAC6G,MAAN,CAAa3G,OAAO,CAAC4G,QAArB,CAAf;AACA,UAAMC,MAAM,GAAG/G,KAAK,CAAC6G,MAAN,CAAa3G,OAAO,CAAC8G,QAArB,CAAf;AACA,QAAI;AAACxC,MAAAA,GAAG,EAAE/B,CAAN;AAAS8B,MAAAA,IAAI,EAAE/B,CAAf;AAAkBkC,MAAAA,MAAM,EAAEuC,EAA1B;AAA8BxC,MAAAA,KAAK,EAAEyC;AAArC,QAA2ClH,KAAK,CAACmH,SAArD;AACA,QAAI7C,GAAJ,EAAS8C,GAAT;;AAEA,QAAI,CAACR,MAAD,IAAW,CAACG,MAAhB,EAAwB;AACtB,aAAO;AAAC7G,QAAAA,OAAO,EAAE;AAAV,OAAP;AACD;;AAED,QAAI0G,MAAJ,EAAY;AACVtC,MAAAA,GAAG,GAAGb,UAAU,CAACmD,MAAD,EAAS1G,OAAO,CAACmH,IAAjB,EAAuB7E,CAAvB,CAAhB;AACA4E,MAAAA,GAAG,GAAG3D,UAAU,CAACmD,MAAD,EAAS1G,OAAO,CAACoH,IAAjB,EAAuBJ,EAAvB,CAAhB;AACA1E,MAAAA,CAAC,GAAGc,IAAI,CAACgB,GAAL,CAASA,GAAT,EAAc8C,GAAd,CAAJ;AACAF,MAAAA,EAAE,GAAG5D,IAAI,CAAC8D,GAAL,CAAS9C,GAAT,EAAc8C,GAAd,CAAL;AACD;;AAED,QAAIL,MAAJ,EAAY;AACVzC,MAAAA,GAAG,GAAGb,UAAU,CAACsD,MAAD,EAAS7G,OAAO,CAACqH,IAAjB,EAAuBN,EAAvB,CAAhB;AACAG,MAAAA,GAAG,GAAG3D,UAAU,CAACsD,MAAD,EAAS7G,OAAO,CAACsH,IAAjB,EAAuB/E,CAAvB,CAAhB;AACAA,MAAAA,CAAC,GAAGa,IAAI,CAACgB,GAAL,CAASA,GAAT,EAAc8C,GAAd,CAAJ;AACAH,MAAAA,EAAE,GAAG3D,IAAI,CAAC8D,GAAL,CAAS9C,GAAT,EAAc8C,GAAd,CAAL;AACD;;AAED,WAAO;AACL5E,MAAAA,CADK;AAELC,MAAAA,CAFK;AAGLyE,MAAAA,EAHK;AAILD,MAAAA,EAJK;AAKLhD,MAAAA,KAAK,EAAEiD,EAAE,GAAG1E,CALP;AAML0B,MAAAA,MAAM,EAAE+C,EAAE,GAAGxE;AANR,KAAP;AAQD;;AAzEiC;;AA4EpC6C,aAAa,CAACmC,EAAd,GAAmB,eAAnB;AAEAnC,aAAa,CAACvG,QAAd,GAAyB;AACvBuD,EAAAA,OAAO,EAAE,IADc;AAEvBoF,EAAAA,gBAAgB,EAAE,IAFK;AAGvBtB,EAAAA,UAAU,EAAE,EAHW;AAIvBE,EAAAA,gBAAgB,EAAE,CAJK;AAKvBR,EAAAA,WAAW,EAAE,CALU;AAMvBS,EAAAA,YAAY,EAAE,CANS;AAOvBO,EAAAA,QAAQ,EAAE,GAPa;AAQvBO,EAAAA,IAAI,EAAEM,SARiB;AASvBL,EAAAA,IAAI,EAAEK,SATiB;AAUvBX,EAAAA,QAAQ,EAAE,GAVa;AAWvBO,EAAAA,IAAI,EAAEI,SAXiB;AAYvBH,EAAAA,IAAI,EAAEG;AAZiB,CAAzB;AAeArC,aAAa,CAACsC,aAAd,GAA8B;AAC5B5B,EAAAA,WAAW,EAAE,OADe;AAE5BE,EAAAA,eAAe,EAAE;AAFW,CAA9B;AAKA,MAAM3C,EAAE,GAAGD,IAAI,CAACC,EAAhB;;AACA,MAAMsE,KAAK,GAAG,CAACrF,CAAD,EAAIsF,IAAJ,EAAUC,EAAV,KAAiBzE,IAAI,CAACgB,GAAL,CAASyD,EAAT,EAAazE,IAAI,CAAC8D,GAAL,CAASU,IAAT,EAAetF,CAAf,CAAb,CAA/B;;AACA,MAAMwF,WAAW,GAAG,CAACC,EAAD,EAAKC,EAAL,EAASC,CAAT,MAAgB;AAAC3F,EAAAA,CAAC,EAAEyF,EAAE,CAACzF,CAAH,GAAO2F,CAAC,IAAID,EAAE,CAAC1F,CAAH,GAAOyF,EAAE,CAACzF,CAAd,CAAZ;AAA8BC,EAAAA,CAAC,EAAEwF,EAAE,CAACxF,CAAH,GAAO0F,CAAC,IAAID,EAAE,CAACzF,CAAH,GAAOwF,EAAE,CAACxF,CAAd;AAAzC,CAAhB,CAApB;;AACA,MAAM2F,YAAY,GAAG,CAAC3F,CAAD,EAAIwF,EAAJ,EAAQC,EAAR,KAAeF,WAAW,CAACC,EAAD,EAAKC,EAAL,EAAS5E,IAAI,CAAC+E,GAAL,CAAS,CAAC5F,CAAC,GAAGwF,EAAE,CAACxF,CAAR,KAAcyF,EAAE,CAACzF,CAAH,GAAOwF,EAAE,CAACxF,CAAxB,CAAT,CAAT,CAAX,CAA0DD,CAA9F;;AACA,MAAM8F,YAAY,GAAG,CAAC9F,CAAD,EAAIyF,EAAJ,EAAQC,EAAR,KAAeF,WAAW,CAACC,EAAD,EAAKC,EAAL,EAAS5E,IAAI,CAAC+E,GAAL,CAAS,CAAC7F,CAAC,GAAGyF,EAAE,CAACzF,CAAR,KAAc0F,EAAE,CAAC1F,CAAH,GAAOyF,EAAE,CAACzF,CAAxB,CAAT,CAAT,CAAX,CAA0DC,CAA9F;;AACA,MAAM8F,SAAS,GAAIC,CAAD,IAAO,OAAOA,CAAP,KAAa,QAAb,IAAyBA,CAAC,CAACC,QAAF,CAAW,GAAX,CAAzB,IAA4CC,UAAU,CAACF,CAAD,CAAV,GAAgB,GAArF;;AAEA,SAASG,gBAAT,CAA0B;AAACnG,EAAAA,CAAD;AAAIC,EAAAA;AAAJ,CAA1B,EAAkCyF,EAAlC,EAAsC;AAAC1D,EAAAA,GAAD;AAAMC,EAAAA,KAAN;AAAaC,EAAAA,MAAb;AAAqBH,EAAAA;AAArB,CAAtC,EAAkE;AAChE,MAAI/B,CAAC,GAAG+B,IAAR,EAAc;AACZ9B,IAAAA,CAAC,GAAGyF,EAAE,CAAC1F,CAAH,GAAO+B,IAAP,GAAcqE,GAAd,GAAoBN,YAAY,CAAC/D,IAAD,EAAO;AAAC/B,MAAAA,CAAD;AAAIC,MAAAA;AAAJ,KAAP,EAAeyF,EAAf,CAApC;AACA1F,IAAAA,CAAC,GAAG+B,IAAJ;AACD;;AACD,MAAI/B,CAAC,GAAGiC,KAAR,EAAe;AACbhC,IAAAA,CAAC,GAAGyF,EAAE,CAAC1F,CAAH,GAAOiC,KAAP,GAAemE,GAAf,GAAqBN,YAAY,CAAC7D,KAAD,EAAQ;AAACjC,MAAAA,CAAD;AAAIC,MAAAA;AAAJ,KAAR,EAAgByF,EAAhB,CAArC;AACA1F,IAAAA,CAAC,GAAGiC,KAAJ;AACD;;AACD,MAAIhC,CAAC,GAAG+B,GAAR,EAAa;AACXhC,IAAAA,CAAC,GAAG0F,EAAE,CAACzF,CAAH,GAAO+B,GAAP,GAAaoE,GAAb,GAAmBR,YAAY,CAAC5D,GAAD,EAAM;AAAChC,MAAAA,CAAD;AAAIC,MAAAA;AAAJ,KAAN,EAAcyF,EAAd,CAAnC;AACAzF,IAAAA,CAAC,GAAG+B,GAAJ;AACD;;AACD,MAAI/B,CAAC,GAAGiC,MAAR,EAAgB;AACdlC,IAAAA,CAAC,GAAG0F,EAAE,CAACzF,CAAH,GAAOiC,MAAP,GAAgBkE,GAAhB,GAAsBR,YAAY,CAAC1D,MAAD,EAAS;AAAClC,MAAAA,CAAD;AAAIC,MAAAA;AAAJ,KAAT,EAAiByF,EAAjB,CAAtC;AACAzF,IAAAA,CAAC,GAAGiC,MAAJ;AACD;;AACD,SAAO;AAAClC,IAAAA,CAAD;AAAIC,IAAAA;AAAJ,GAAP;AACD;;AAED,SAASoG,eAAT,CAAyBZ,EAAzB,EAA6BC,EAA7B,EAAiCY,IAAjC,EAAuC;AACrC,QAAM;AAACtG,IAAAA,CAAD;AAAIC,IAAAA;AAAJ,MAASkG,gBAAgB,CAACV,EAAD,EAAKC,EAAL,EAASY,IAAT,CAA/B;AACA,QAAM;AAACtG,IAAAA,CAAC,EAAE0E,EAAJ;AAAQzE,IAAAA,CAAC,EAAEwE;AAAX,MAAiB0B,gBAAgB,CAACT,EAAD,EAAKD,EAAL,EAASa,IAAT,CAAvC;AACA,SAAO;AAACtG,IAAAA,CAAD;AAAIC,IAAAA,CAAJ;AAAOyE,IAAAA,EAAP;AAAWD,IAAAA,EAAX;AAAehD,IAAAA,KAAK,EAAEX,IAAI,CAAC+E,GAAL,CAASnB,EAAE,GAAG1E,CAAd,CAAtB;AAAwC0B,IAAAA,MAAM,EAAEZ,IAAI,CAAC+E,GAAL,CAASpB,EAAE,GAAGxE,CAAd;AAAhD,GAAP;AACD;;AAED,MAAMsG,cAAN,SAA6BlK,OAA7B,CAAqC;AACnCmK,EAAAA,UAAU,CAACxG,CAAD,EAAIC,CAAJ,EAAOwG,OAAO,GAAG,KAAjB,EAAwB;AAChC;AACA,UAAMC,GAAG,GAAGC,CAAC,IAAIA,CAAC,GAAGA,CAArB;;AACA,UAAM;AAAC3G,MAAAA,CAAC,EAAE4G,EAAJ;AAAQ3G,MAAAA,CAAC,EAAE4G,EAAX;AAAenC,MAAAA,EAAf;AAAmBD,MAAAA;AAAnB,QAAyB,IAA/B;AACA,UAAMqC,EAAE,GAAGpC,EAAE,GAAGkC,EAAhB;AACA,UAAMG,EAAE,GAAGtC,EAAE,GAAGoC,EAAhB;AACA,UAAMG,KAAK,GAAGN,GAAG,CAACI,EAAD,CAAH,GAAUJ,GAAG,CAACK,EAAD,CAA3B;AACA,UAAMpB,CAAC,GAAGqB,KAAK,KAAK,CAAV,GAAc,CAAC,CAAf,GAAmB,CAAC,CAAChH,CAAC,GAAG4G,EAAL,IAAWE,EAAX,GAAgB,CAAC7G,CAAC,GAAG4G,EAAL,IAAWE,EAA5B,IAAkCC,KAA/D;AACA,QAAIC,EAAJ,EAAQC,EAAR;;AACA,QAAIvB,CAAC,GAAG,CAAR,EAAW;AACTsB,MAAAA,EAAE,GAAGL,EAAL;AACAM,MAAAA,EAAE,GAAGL,EAAL;AACD,KAHD,MAGO,IAAIlB,CAAC,GAAG,CAAR,EAAW;AAChBsB,MAAAA,EAAE,GAAGvC,EAAL;AACAwC,MAAAA,EAAE,GAAGzC,EAAL;AACD,KAHM,MAGA;AACLwC,MAAAA,EAAE,GAAGL,EAAE,GAAGjB,CAAC,GAAGmB,EAAd;AACAI,MAAAA,EAAE,GAAGL,EAAE,GAAGlB,CAAC,GAAGoB,EAAd;AACD;;AACD,WAAQL,GAAG,CAAC1G,CAAC,GAAGiH,EAAL,CAAH,GAAcP,GAAG,CAACzG,CAAC,GAAGiH,EAAL,CAAlB,GAA8BT,OAArC;AACD;;AAEDU,EAAAA,cAAc,GAAG;AACf,UAAMC,KAAK,GAAG,KAAK1J,OAAL,CAAa0J,KAA3B;AACA,WAAOA,KAAK,IAAIA,KAAK,CAACC,OAAf,IAA0BD,KAAK,CAACE,OAAvC;AACD;;AAEDC,EAAAA,SAAS,CAACxE,MAAD,EAASC,MAAT,EAAiB;AACxB,UAAM;AAACwE,MAAAA;AAAD,QAAc,IAApB;;AACA,QAAI,CAACA,SAAD,IAAc,CAAC,KAAKL,cAAL,EAAnB,EAA0C;AACxC,aAAO,KAAP;AACD;;AAED,UAAM;AAACnH,MAAAA,CAAD;AAAIC,MAAAA;AAAJ,QAASsC,OAAO,CAAC;AAACvC,MAAAA,CAAC,EAAE+C,MAAJ;AAAY9C,MAAAA,CAAC,EAAE+C;AAAf,KAAD,EAAyBwE,SAAzB,EAAoC,CAACA,SAAS,CAACC,QAA/C,CAAtB;AACA,UAAMC,EAAE,GAAGF,SAAS,CAAC/F,KAAV,GAAkB,CAA7B;AACA,UAAMkG,EAAE,GAAGH,SAAS,CAAC9F,MAAV,GAAmB,CAA9B;AACA,WAAO1B,CAAC,IAAIwH,SAAS,CAACxH,CAAV,GAAc0H,EAAnB,IAAyB1H,CAAC,IAAIwH,SAAS,CAACxH,CAAV,GAAc0H,EAA5C,IACLzH,CAAC,IAAIuH,SAAS,CAACvH,CAAV,GAAc0H,EADd,IACoB1H,CAAC,IAAIuH,SAAS,CAACvH,CAAV,GAAc0H,EAD9C;AAED;;AAED5H,EAAAA,OAAO,CAACC,CAAD,EAAIC,CAAJ,EAAO;AACZ,UAAMwG,OAAO,GAAG,KAAK/I,OAAL,CAAa4F,WAAb,IAA4B,CAA5C;AACA,WAAO,KAAKkD,UAAL,CAAgBxG,CAAhB,EAAmBC,CAAnB,EAAsBwG,OAAtB,KAAkC,KAAKc,SAAL,CAAevH,CAAf,EAAkBC,CAAlB,CAAzC;AACD;;AAEDI,EAAAA,cAAc,GAAG;AACf,WAAO;AACLL,MAAAA,CAAC,EAAE,CAAC,KAAK0E,EAAL,GAAU,KAAK1E,CAAhB,IAAqB,CADnB;AAELC,MAAAA,CAAC,EAAE,CAAC,KAAKwE,EAAL,GAAU,KAAKxE,CAAhB,IAAqB;AAFnB,KAAP;AAID;;AAEDkD,EAAAA,IAAI,CAAC3B,GAAD,EAAM;AACR,UAAM;AAACxB,MAAAA,CAAD;AAAIC,MAAAA,CAAJ;AAAOyE,MAAAA,EAAP;AAAWD,MAAAA,EAAX;AAAe/G,MAAAA;AAAf,QAA0B,IAAhC;AACA8D,IAAAA,GAAG,CAAC4B,IAAJ;AAEA5B,IAAAA,GAAG,CAAC6B,SAAJ,GAAgB3F,OAAO,CAAC4F,WAAxB;AACA9B,IAAAA,GAAG,CAAC+B,WAAJ,GAAkB7F,OAAO,CAAC8F,WAA1B;AACAhC,IAAAA,GAAG,CAACmC,WAAJ,CAAgBjG,OAAO,CAACkG,UAAxB;AACApC,IAAAA,GAAG,CAACqC,cAAJ,GAAqBnG,OAAO,CAACoG,gBAA7B,CAPQ,CASR;;AACAtC,IAAAA,GAAG,CAACI,SAAJ;AACAJ,IAAAA,GAAG,CAACW,MAAJ,CAAWnC,CAAX,EAAcC,CAAd;AACAuB,IAAAA,GAAG,CAACoG,MAAJ,CAAWlD,EAAX,EAAeD,EAAf;AACAjD,IAAAA,GAAG,CAACyC,MAAJ;AAEAzC,IAAAA,GAAG,CAAC0C,OAAJ;AACD;;AAED2D,EAAAA,SAAS,CAACrG,GAAD,EAAMmD,SAAN,EAAiB;AACxB,QAAI,KAAKwC,cAAL,EAAJ,EAA2B;AACzB3F,MAAAA,GAAG,CAAC4B,IAAJ;AACAyE,MAAAA,SAAS,CAACrG,GAAD,EAAM,IAAN,EAAYmD,SAAZ,CAAT;AACAnD,MAAAA,GAAG,CAAC0C,OAAJ;AACD;AACF;;AAEDC,EAAAA,wBAAwB,CAAC3G,KAAD,EAAQE,OAAR,EAAiB;AACvC,UAAMwD,KAAK,GAAG1D,KAAK,CAAC6G,MAAN,CAAa3G,OAAO,CAACoK,OAArB,CAAd;AACA,QAAI;AAAC9F,MAAAA,GAAG,EAAE/B,CAAN;AAAS8B,MAAAA,IAAI,EAAE/B,CAAf;AAAkBkC,MAAAA,MAAM,EAAEuC,EAA1B;AAA8BxC,MAAAA,KAAK,EAAEyC;AAArC,QAA2ClH,KAAK,CAACmH,SAArD;AACA,QAAI7C,GAAJ,EAAS8C,GAAT;;AAEA,QAAI1D,KAAJ,EAAW;AACTY,MAAAA,GAAG,GAAGb,UAAU,CAACC,KAAD,EAAQxD,OAAO,CAACyD,KAAhB,EAAuBiF,GAAvB,CAAhB;AACAxB,MAAAA,GAAG,GAAG3D,UAAU,CAACC,KAAD,EAAQxD,OAAO,CAACqK,QAAhB,EAA0BjG,GAA1B,CAAhB;;AACA,UAAIZ,KAAK,CAAC8G,YAAN,EAAJ,EAA0B;AACxBhI,QAAAA,CAAC,GAAG8B,GAAJ;AACA4C,QAAAA,EAAE,GAAGE,GAAL;AACD,OAHD,MAGO;AACL3E,QAAAA,CAAC,GAAG6B,GAAJ;AACA2C,QAAAA,EAAE,GAAGG,GAAL;AACD;AACF,KAVD,MAUO;AACL,YAAMR,MAAM,GAAG5G,KAAK,CAAC6G,MAAN,CAAa3G,OAAO,CAAC4G,QAArB,CAAf;AACA,YAAMC,MAAM,GAAG/G,KAAK,CAAC6G,MAAN,CAAa3G,OAAO,CAAC8G,QAArB,CAAf;;AAEA,UAAIJ,MAAJ,EAAY;AACVpE,QAAAA,CAAC,GAAGiB,UAAU,CAACmD,MAAD,EAAS1G,OAAO,CAACmH,IAAjB,EAAuB7E,CAAvB,CAAd;AACA0E,QAAAA,EAAE,GAAGzD,UAAU,CAACmD,MAAD,EAAS1G,OAAO,CAACoH,IAAjB,EAAuBJ,EAAvB,CAAf;AACD;;AAED,UAAIH,MAAJ,EAAY;AACVtE,QAAAA,CAAC,GAAGgB,UAAU,CAACsD,MAAD,EAAS7G,OAAO,CAACqH,IAAjB,EAAuB9E,CAAvB,CAAd;AACAwE,QAAAA,EAAE,GAAGxD,UAAU,CAACsD,MAAD,EAAS7G,OAAO,CAACsH,IAAjB,EAAuBP,EAAvB,CAAf;AACD;AACF;;AACD,WAAO4B,eAAe,CAAC;AAACrG,MAAAA,CAAD;AAAIC,MAAAA;AAAJ,KAAD,EAAS;AAACD,MAAAA,CAAC,EAAE0E,EAAJ;AAAQzE,MAAAA,CAAC,EAAEwE;AAAX,KAAT,EAAyBjH,KAAK,CAACmH,SAA/B,CAAtB;AACD;;AA7GkC;;AAgHrC4B,cAAc,CAACtB,EAAf,GAAoB,gBAApB;AACAsB,cAAc,CAAChK,QAAf,GAA0B;AACxBuD,EAAAA,OAAO,EAAE,IADe;AAExBoF,EAAAA,gBAAgB,EAAE,IAFM;AAGxB5B,EAAAA,WAAW,EAAE,CAHW;AAIxBM,EAAAA,UAAU,EAAE,EAJY;AAKxBE,EAAAA,gBAAgB,EAAE,CALM;AAMxBsD,EAAAA,KAAK,EAAE;AACL1D,IAAAA,eAAe,EAAE,iBADZ;AAELuE,IAAAA,QAAQ,EAAE9C,SAFL;AAGL+C,IAAAA,IAAI,EAAE;AACJC,MAAAA,MAAM,EAAEhD,SADJ;AAEJiD,MAAAA,UAAU,EAAEjD,SAFR;AAGJkD,MAAAA,IAAI,EAAElD,SAHF;AAIJmD,MAAAA,KAAK,EAAE,MAJH;AAKJC,MAAAA,MAAM,EAAEpD;AALJ,KAHD;AAULqD,IAAAA,KAAK,EAAE,MAVF;AAWLC,IAAAA,QAAQ,EAAE,CAXL;AAYLC,IAAAA,QAAQ,EAAE,CAZL;AAaLjB,IAAAA,QAAQ,EAAE,CAbL;AAcL1D,IAAAA,YAAY,EAAE,CAdT;AAeLtE,IAAAA,QAAQ,EAAE,QAfL;AAgBLkJ,IAAAA,OAAO,EAAE,CAhBJ;AAiBLC,IAAAA,OAAO,EAAE,CAjBJ;AAkBLC,IAAAA,SAAS,EAAE,QAlBN;AAmBLxB,IAAAA,OAAO,EAAE,KAnBJ;AAoBLC,IAAAA,OAAO,EAAE;AApBJ,GANiB;AA4BxBnG,EAAAA,KAAK,EAAEgE,SA5BiB;AA6BxB4C,EAAAA,QAAQ,EAAE5C,SA7Bc;AA8BxB2C,EAAAA,OAAO,EAAE3C,SA9Be;AA+BxBb,EAAAA,QAAQ,EAAE,GA/Bc;AAgCxBO,EAAAA,IAAI,EAAEM,SAhCkB;AAiCxBL,EAAAA,IAAI,EAAEK,SAjCkB;AAkCxBX,EAAAA,QAAQ,EAAE,GAlCc;AAmCxBO,EAAAA,IAAI,EAAEI,SAnCkB;AAoCxBH,EAAAA,IAAI,EAAEG;AApCkB,CAA1B;AAuCAoB,cAAc,CAACnB,aAAf,GAA+B;AAC7B5B,EAAAA,WAAW,EAAE;AADgB,CAA/B;;AAIA,SAASsF,qBAAT,CAA+BC,IAA/B,EAAqC;AACnC,QAAM;AAAC/I,IAAAA,CAAD;AAAIC,IAAAA,CAAJ;AAAOyE,IAAAA,EAAP;AAAWD,IAAAA;AAAX,MAAiBsE,IAAvB;AACA,QAAMtB,QAAQ,GAAG3G,IAAI,CAACkI,KAAL,CAAWvE,EAAE,GAAGxE,CAAhB,EAAmByE,EAAE,GAAG1E,CAAxB,CAAjB,CAFmC,CAGnC;;AACA,SAAOyH,QAAQ,GAAG1G,EAAE,GAAG,CAAhB,GAAoB0G,QAAQ,GAAG1G,EAA/B,GAAoC0G,QAAQ,GAAG1G,EAAE,GAAG,CAAC,CAAjB,GAAqB0G,QAAQ,GAAG1G,EAAhC,GAAqC0G,QAAhF;AACD;;AAED,SAASI,SAAT,CAAmBrG,GAAnB,EAAwBuH,IAAxB,EAA8BpE,SAA9B,EAAyC;AACvC,QAAMyC,KAAK,GAAG2B,IAAI,CAACrL,OAAL,CAAa0J,KAA3B;AAEA5F,EAAAA,GAAG,CAAC0G,IAAJ,GAAWtL,YAAY,CAACwK,KAAK,CAACc,IAAP,CAAvB;AAEA,QAAM;AAACzG,IAAAA,KAAD;AAAQC,IAAAA;AAAR,MAAkBuH,YAAY,CAACzH,GAAD,EAAM4F,KAAN,CAApC;AACA,QAAM9E,IAAI,GAAGyG,IAAI,CAACvB,SAAL,GAAiB0B,sBAAsB,CAACH,IAAD,EAAOtH,KAAP,EAAcC,MAAd,EAAsBiD,SAAtB,CAApD;AAEAnD,EAAAA,GAAG,CAAC2H,SAAJ,CAAc7G,IAAI,CAACtC,CAAnB,EAAsBsC,IAAI,CAACrC,CAA3B;AACAuB,EAAAA,GAAG,CAAC4H,MAAJ,CAAW9G,IAAI,CAACmF,QAAhB;AAEAjG,EAAAA,GAAG,CAACiC,SAAJ,GAAgB2D,KAAK,CAAC1D,eAAtB;AACAnC,EAAAA,WAAW,CAACC,GAAD,EAAM,EAAEC,KAAK,GAAG,CAAV,CAAN,EAAoB,EAAEC,MAAM,GAAG,CAAX,CAApB,EAAmCD,KAAnC,EAA0CC,MAA1C,EAAkD0F,KAAK,CAACrD,YAAxD,CAAX;AACAvC,EAAAA,GAAG,CAACwC,IAAJ;AAEAxC,EAAAA,GAAG,CAACiC,SAAJ,GAAgB2D,KAAK,CAACoB,KAAtB;;AACA,MAAI3L,OAAO,CAACuK,KAAK,CAACE,OAAP,CAAX,EAA4B;AAC1B9F,IAAAA,GAAG,CAACqH,SAAJ,GAAgBzB,KAAK,CAACyB,SAAtB;AACA,UAAM7I,CAAC,GAAGqJ,wBAAwB,CAACjC,KAAD,EAAQ3F,KAAR,CAAlC;AACA,QAAI6H,aAAa,GAAG,EAAE5H,MAAM,GAAG,CAAX,IAAgB0F,KAAK,CAACsB,QAA1C;;AACA,SAAK,IAAIa,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnC,KAAK,CAACE,OAAN,CAAckC,MAAlC,EAA0CD,CAAC,EAA3C,EAA+C;AAC7C/H,MAAAA,GAAG,CAACiI,YAAJ,GAAmB,KAAnB;AACAjI,MAAAA,GAAG,CAACkI,QAAJ,CACEtC,KAAK,CAACE,OAAN,CAAciC,CAAd,CADF,EAEEvJ,CAFF,EAGEsJ,aAHF;AAKAA,MAAAA,aAAa,IAAIlC,KAAK,CAACc,IAAN,CAAWG,IAAX,GAAkBjB,KAAK,CAACsB,QAAzC;AACD;AACF,GAbD,MAaO,IAAItB,KAAK,CAACE,OAAN,YAAyBqC,KAA7B,EAAoC;AACzC,UAAM3J,CAAC,GAAG,EAAEyB,KAAK,GAAG,CAAV,IAAe2F,KAAK,CAACqB,QAA/B;AACA,UAAMxI,CAAC,GAAG,EAAEyB,MAAM,GAAG,CAAX,IAAgB0F,KAAK,CAACsB,QAAhC;AACAlH,IAAAA,GAAG,CAACoI,SAAJ,CAAcxC,KAAK,CAACE,OAApB,EAA6BtH,CAA7B,EAAgCC,CAAhC,EAAmCwB,KAAK,GAAI,IAAI2F,KAAK,CAACqB,QAAtD,EAAiE/G,MAAM,GAAI,IAAI0F,KAAK,CAACsB,QAArF;AACD,GAJM,MAIA;AACLlH,IAAAA,GAAG,CAACqH,SAAJ,GAAgB,QAAhB;AACArH,IAAAA,GAAG,CAACiI,YAAJ,GAAmB,QAAnB;AACAjI,IAAAA,GAAG,CAACkI,QAAJ,CAAatC,KAAK,CAACE,OAAnB,EAA4B,CAA5B,EAA+B,CAA/B;AACD;AACF;;AAED,SAAS+B,wBAAT,CAAkCjC,KAAlC,EAAyC3F,KAAzC,EAAgD;AAC9C,QAAM;AAACoH,IAAAA,SAAD;AAAYJ,IAAAA;AAAZ,MAAwBrB,KAA9B;;AACA,MAAIyB,SAAS,KAAK,OAAlB,EAA2B;AACzB,WAAO,EAAEpH,KAAK,GAAG,CAAV,IAAegH,QAAtB;AACD,GAFD,MAEO,IAAII,SAAS,KAAK,KAAlB,EAAyB;AAC9B,WAAO,EAAEpH,KAAK,GAAG,CAAV,IAAegH,QAAtB;AACD;;AACD,SAAO,CAAP;AACD;;AAED,SAASoB,YAAT,CAAsBxB,IAAtB,EAA4BlH,KAA5B,EAAmC;AACjC,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B,WAAOA,KAAP;AACD,GAFD,MAEO,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AACpC,WAAO4E,SAAS,CAAC5E,KAAD,CAAT,GAAmBkH,IAA1B;AACD;;AACD,SAAOA,IAAP;AACD;;AAED,MAAMyB,UAAU,GAAG,IAAIC,GAAJ,EAAnB;;AACA,SAASd,YAAT,CAAsBzH,GAAtB,EAA2B4F,KAA3B,EAAkC;AAChC,QAAME,OAAO,GAAGF,KAAK,CAACE,OAAtB;;AACA,MAAIA,OAAO,YAAYqC,KAAvB,EAA8B;AAC5B,WAAO;AACLlI,MAAAA,KAAK,EAAEoI,YAAY,CAACvC,OAAO,CAAC7F,KAAT,EAAgB2F,KAAK,CAAC3F,KAAtB,CAAZ,GAA2C,IAAI2F,KAAK,CAACqB,QADvD;AAEL/G,MAAAA,MAAM,EAAEmI,YAAY,CAACvC,OAAO,CAAC5F,MAAT,EAAiB0F,KAAK,CAAC1F,MAAvB,CAAZ,GAA6C,IAAI0F,KAAK,CAACsB;AAF1D,KAAP;AAID;;AACD,QAAMsB,KAAK,GAAGnN,OAAO,CAACyK,OAAD,CAAP,GAAmBA,OAAnB,GAA6B,CAACA,OAAD,CAA3C;AACA,QAAM2C,KAAK,GAAGD,KAAK,CAACR,MAApB;AACA,MAAI/H,KAAK,GAAG,CAAZ;;AACA,OAAK,IAAI8H,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGU,KAApB,EAA2BV,CAAC,EAA5B,EAAgC;AAC9B,UAAMW,IAAI,GAAGF,KAAK,CAACT,CAAD,CAAlB;;AACA,QAAI,CAACO,UAAU,CAACK,GAAX,CAAeD,IAAf,CAAL,EAA2B;AACzBJ,MAAAA,UAAU,CAACM,GAAX,CAAeF,IAAf,EAAqB1I,GAAG,CAAC6I,WAAJ,CAAgBH,IAAhB,EAAsBzI,KAA3C;AACD;;AACDA,IAAAA,KAAK,GAAGX,IAAI,CAAC8D,GAAL,CAASnD,KAAT,EAAgBqI,UAAU,CAACQ,GAAX,CAAeJ,IAAf,CAAhB,CAAR;AACD;;AACDzI,EAAAA,KAAK,IAAI,IAAI2F,KAAK,CAACqB,QAAnB;AAEA,SAAO;AACLhH,IAAAA,KADK;AAELC,IAAAA,MAAM,EAAEuI,KAAK,GAAG7C,KAAK,CAACc,IAAN,CAAWG,IAAnB,GAA2B,CAAC4B,KAAK,GAAG,CAAT,IAAc7C,KAAK,CAACsB;AAFlD,GAAP;AAID;;AAED,SAASQ,sBAAT,CAAgCH,IAAhC,EAAsCtH,KAAtC,EAA6CC,MAA7C,EAAqDiD,SAArD,EAAgE;AAC9D,QAAMyC,KAAK,GAAG2B,IAAI,CAACrL,OAAL,CAAa0J,KAA3B;AACA,QAAM;AAACuB,IAAAA,OAAD;AAAUC,IAAAA,OAAV;AAAmBH,IAAAA,QAAnB;AAA6BC,IAAAA,QAA7B;AAAuCjJ,IAAAA;AAAvC,MAAmD2H,KAAzD;AACA,QAAM3B,EAAE,GAAG;AAACzF,IAAAA,CAAC,EAAE+I,IAAI,CAAC/I,CAAT;AAAYC,IAAAA,CAAC,EAAE8I,IAAI,CAAC9I;AAApB,GAAX;AACA,QAAMyF,EAAE,GAAG;AAAC1F,IAAAA,CAAC,EAAE+I,IAAI,CAACrE,EAAT;AAAazE,IAAAA,CAAC,EAAE8I,IAAI,CAACtE;AAArB,GAAX;AACA,QAAMgD,QAAQ,GAAGL,KAAK,CAACK,QAAN,KAAmB,MAAnB,GAA4BqB,qBAAqB,CAACC,IAAD,CAAjD,GAA0DjM,SAAS,CAACsK,KAAK,CAACK,QAAP,CAApF;AACA,QAAMY,IAAI,GAAGkC,WAAW,CAAC9I,KAAD,EAAQC,MAAR,EAAgB+F,QAAhB,CAAxB;AACA,QAAM9B,CAAC,GAAG6E,UAAU,CAACzB,IAAD,EAAOtJ,QAAP,EAAiB4I,IAAjB,EAAuB1D,SAAvB,CAApB;AACA,QAAM8F,EAAE,GAAGjF,WAAW,CAACC,EAAD,EAAKC,EAAL,EAASC,CAAT,CAAtB;AACA,QAAM+E,gBAAgB,GAAG;AAACrC,IAAAA,IAAI,EAAEA,IAAI,CAACsC,CAAZ;AAAe7I,IAAAA,GAAG,EAAE6C,SAAS,CAAC5C,IAA9B;AAAoC6C,IAAAA,GAAG,EAAED,SAAS,CAAC1C,KAAnD;AAA0D2I,IAAAA,OAAO,EAAEnC;AAAnE,GAAzB;AACA,QAAMoC,gBAAgB,GAAG;AAACxC,IAAAA,IAAI,EAAEA,IAAI,CAACyC,CAAZ;AAAehJ,IAAAA,GAAG,EAAE6C,SAAS,CAAC3C,GAA9B;AAAmC4C,IAAAA,GAAG,EAAED,SAAS,CAACzC,MAAlD;AAA0D0I,IAAAA,OAAO,EAAElC;AAAnE,GAAzB;AAEA,SAAO;AACL1I,IAAAA,CAAC,EAAE+K,qBAAqB,CAACN,EAAE,CAACzK,CAAJ,EAAO0K,gBAAP,CAArB,GAAgD/B,OAD9C;AAEL1I,IAAAA,CAAC,EAAE8K,qBAAqB,CAACN,EAAE,CAACxK,CAAJ,EAAO4K,gBAAP,CAArB,GAAgDjC,OAF9C;AAGLnH,IAAAA,KAHK;AAILC,IAAAA,MAJK;AAKL+F,IAAAA;AALK,GAAP;AAOD;;AAED,SAAS8C,WAAT,CAAqB9I,KAArB,EAA4BC,MAA5B,EAAoC+F,QAApC,EAA8C;AAC5C,QAAM/E,GAAG,GAAG5B,IAAI,CAAC4B,GAAL,CAAS+E,QAAT,CAAZ;AACA,QAAM9E,GAAG,GAAG7B,IAAI,CAAC6B,GAAL,CAAS8E,QAAT,CAAZ;AACA,SAAO;AACLkD,IAAAA,CAAC,EAAE7J,IAAI,CAAC+E,GAAL,CAASpE,KAAK,GAAGiB,GAAjB,IAAwB5B,IAAI,CAAC+E,GAAL,CAASnE,MAAM,GAAGiB,GAAlB,CADtB;AAELmI,IAAAA,CAAC,EAAEhK,IAAI,CAAC+E,GAAL,CAASpE,KAAK,GAAGkB,GAAjB,IAAwB7B,IAAI,CAAC+E,GAAL,CAASnE,MAAM,GAAGgB,GAAlB;AAFtB,GAAP;AAID;;AAED,SAAS8H,UAAT,CAAoBzB,IAApB,EAA0BtJ,QAA1B,EAAoCuL,OAApC,EAA6CrG,SAA7C,EAAwD;AACtD,MAAIgB,CAAC,GAAG,GAAR;AACA,QAAMsF,KAAK,GAAGC,WAAW,CAACnC,IAAD,EAAOpE,SAAP,CAAzB;AACA,QAAMyC,KAAK,GAAG2B,IAAI,CAACrL,OAAL,CAAa0J,KAA3B;;AACA,MAAI3H,QAAQ,KAAK,OAAjB,EAA0B;AACxBkG,IAAAA,CAAC,GAAGwF,gBAAgB,CAAC;AAACR,MAAAA,CAAC,EAAE5B,IAAI,CAACrE,EAAL,GAAUqE,IAAI,CAAC/I,CAAnB;AAAsB8K,MAAAA,CAAC,EAAE/B,IAAI,CAACtE,EAAL,GAAUsE,IAAI,CAAC9I;AAAxC,KAAD,EAA6C+K,OAA7C,EAAsD5D,KAAtD,EAA6D6D,KAA7D,CAApB;AACD,GAFD,MAEO,IAAIxL,QAAQ,KAAK,KAAjB,EAAwB;AAC7BkG,IAAAA,CAAC,GAAG,IAAIwF,gBAAgB,CAAC;AAACR,MAAAA,CAAC,EAAE5B,IAAI,CAAC/I,CAAL,GAAS+I,IAAI,CAACrE,EAAlB;AAAsBoG,MAAAA,CAAC,EAAE/B,IAAI,CAAC9I,CAAL,GAAS8I,IAAI,CAACtE;AAAvC,KAAD,EAA6CuG,OAA7C,EAAsD5D,KAAtD,EAA6D6D,KAA7D,CAAxB;AACD;;AACD,SAAOtF,CAAP;AACD;;AAED,SAASwF,gBAAT,CAA0BC,QAA1B,EAAoCC,SAApC,EAA+CjE,KAA/C,EAAsD6D,KAAtD,EAA6D;AAC3D,QAAM;AAACxC,IAAAA,QAAD;AAAWC,IAAAA;AAAX,MAAuBtB,KAA7B;AACA,QAAMkE,KAAK,GAAGF,QAAQ,CAACT,CAAT,GAAaM,KAAK,CAACnE,EAAjC;AACA,QAAMyE,KAAK,GAAGH,QAAQ,CAACN,CAAT,GAAaG,KAAK,CAAClE,EAAjC;AACA,QAAM/G,CAAC,GAAIsL,KAAK,GAAG,CAAT,IAAgB,CAACD,SAAS,CAACV,CAAV,GAAc,CAAd,GAAkBlC,QAAlB,GAA6BwC,KAAK,CAACjL,CAApC,IAAyCsL,KAAnE;AACA,QAAMrL,CAAC,GAAIsL,KAAK,GAAG,CAAT,IAAgB,CAACF,SAAS,CAACP,CAAV,GAAc,CAAd,GAAkBpC,QAAlB,GAA6BuC,KAAK,CAAChL,CAApC,IAAyCsL,KAAnE;AACA,SAAOlG,KAAK,CAACvE,IAAI,CAAC8D,GAAL,CAAS5E,CAAT,EAAYC,CAAZ,CAAD,EAAiB,CAAjB,EAAoB,IAApB,CAAZ;AACD;;AAED,SAASiL,WAAT,CAAqBnC,IAArB,EAA2BpE,SAA3B,EAAsC;AACpC,QAAM;AAAC3E,IAAAA,CAAD;AAAI0E,IAAAA,EAAJ;AAAQzE,IAAAA,CAAR;AAAWwE,IAAAA;AAAX,MAAiBsE,IAAvB;AACA,QAAMpD,CAAC,GAAG7E,IAAI,CAACgB,GAAL,CAAS7B,CAAT,EAAYwE,EAAZ,IAAkBE,SAAS,CAAC3C,GAAtC;AACA,QAAMwJ,CAAC,GAAG1K,IAAI,CAACgB,GAAL,CAAS9B,CAAT,EAAY0E,EAAZ,IAAkBC,SAAS,CAAC5C,IAAtC;AACA,QAAMrB,CAAC,GAAGiE,SAAS,CAACzC,MAAV,GAAmBpB,IAAI,CAAC8D,GAAL,CAAS3E,CAAT,EAAYwE,EAAZ,CAA7B;AACA,QAAM5C,CAAC,GAAG8C,SAAS,CAAC1C,KAAV,GAAkBnB,IAAI,CAAC8D,GAAL,CAAS5E,CAAT,EAAY0E,EAAZ,CAA5B;AACA,SAAO;AACL1E,IAAAA,CAAC,EAAEc,IAAI,CAACgB,GAAL,CAAS0J,CAAT,EAAY3J,CAAZ,CADE;AAEL5B,IAAAA,CAAC,EAAEa,IAAI,CAACgB,GAAL,CAAS6D,CAAT,EAAYjF,CAAZ,CAFE;AAGLoG,IAAAA,EAAE,EAAE0E,CAAC,GAAG3J,CAAJ,GAAQ,CAAR,GAAY,CAAC,CAHZ;AAILkF,IAAAA,EAAE,EAAEpB,CAAC,GAAGjF,CAAJ,GAAQ,CAAR,GAAY,CAAC;AAJZ,GAAP;AAMD;;AAED,SAASqK,qBAAT,CAA+BU,UAA/B,EAA2CC,UAA3C,EAAuD;AACrD,QAAM;AAACrD,IAAAA,IAAD;AAAOvG,IAAAA,GAAP;AAAY8C,IAAAA,GAAZ;AAAiBgG,IAAAA;AAAjB,MAA4Bc,UAAlC;AACA,QAAMC,QAAQ,GAAGtD,IAAI,GAAG,CAAxB;;AAEA,MAAIA,IAAI,GAAGzD,GAAG,GAAG9C,GAAjB,EAAsB;AACpB;AACA,WAAO,CAAC8C,GAAG,GAAG9C,GAAP,IAAc,CAArB;AACD;;AAED,MAAIA,GAAG,IAAK2J,UAAU,GAAGb,OAAb,GAAuBe,QAAnC,EAA8C;AAC5CF,IAAAA,UAAU,GAAG3J,GAAG,GAAG8I,OAAN,GAAgBe,QAA7B;AACD;;AAED,MAAI/G,GAAG,IAAK6G,UAAU,GAAGb,OAAb,GAAuBe,QAAnC,EAA8C;AAC5CF,IAAAA,UAAU,GAAG7G,GAAG,GAAGgG,OAAN,GAAgBe,QAA7B;AACD;;AAED,SAAOF,UAAP;AACD;;AAED,MAAMG,iBAAN,SAAgC9I,aAAhC,CAA8C;AAE5C/C,EAAAA,OAAO,CAACC,CAAD,EAAIC,CAAJ,EAAO;AACZ,WAAO4L,cAAc,CAAC;AAAC7L,MAAAA,CAAD;AAAIC,MAAAA;AAAJ,KAAD,EAAS,IAAT,CAArB;AACD;;AAEDkD,EAAAA,IAAI,CAAC3B,GAAD,EAAM;AACR,UAAM;AAACC,MAAAA,KAAD;AAAQC,MAAAA,MAAR;AAAgBhE,MAAAA;AAAhB,QAA2B,IAAjC;AACA,UAAM0C,MAAM,GAAG,KAAKC,cAAL,EAAf;AAEAmB,IAAAA,GAAG,CAAC4B,IAAJ;AAEA5B,IAAAA,GAAG,CAACI,SAAJ;AAEAJ,IAAAA,GAAG,CAAC6B,SAAJ,GAAgB3F,OAAO,CAAC4F,WAAxB;AACA9B,IAAAA,GAAG,CAAC+B,WAAJ,GAAkB7F,OAAO,CAAC8F,WAA1B;AACAhC,IAAAA,GAAG,CAACiC,SAAJ,GAAgB/F,OAAO,CAACgG,eAAxB;AAEAlC,IAAAA,GAAG,CAACmC,WAAJ,CAAgBjG,OAAO,CAACkG,UAAxB;AACApC,IAAAA,GAAG,CAACqC,cAAJ,GAAqBnG,OAAO,CAACoG,gBAA7B;AAEAtC,IAAAA,GAAG,CAACsK,OAAJ,CAAY1L,MAAM,CAACJ,CAAnB,EAAsBI,MAAM,CAACH,CAA7B,EAAgCyB,MAAM,GAAG,CAAzC,EAA4CD,KAAK,GAAG,CAApD,EAAuDX,IAAI,CAACC,EAAL,GAAU,CAAjE,EAAoE,CAApE,EAAuE,IAAID,IAAI,CAACC,EAAhF;AAEAS,IAAAA,GAAG,CAACwC,IAAJ;AACAxC,IAAAA,GAAG,CAACyC,MAAJ;AAEAzC,IAAAA,GAAG,CAAC0C,OAAJ;AACD;;AA3B2C;;AA8B9C0H,iBAAiB,CAAC3G,EAAlB,GAAuB,mBAAvB;AAEA2G,iBAAiB,CAACrP,QAAlB,GAA6B;AAC3BuD,EAAAA,OAAO,EAAE,IADkB;AAE3BoF,EAAAA,gBAAgB,EAAE,IAFS;AAG3BtB,EAAAA,UAAU,EAAE,EAHe;AAI3BE,EAAAA,gBAAgB,EAAE,CAJS;AAK3BR,EAAAA,WAAW,EAAE,CALc;AAM3BgB,EAAAA,QAAQ,EAAE,GANiB;AAO3BO,EAAAA,IAAI,EAAEM,SAPqB;AAQ3BL,EAAAA,IAAI,EAAEK,SARqB;AAS3BX,EAAAA,QAAQ,EAAE,GATiB;AAU3BO,EAAAA,IAAI,EAAEI,SAVqB;AAW3BH,EAAAA,IAAI,EAAEG;AAXqB,CAA7B;AAcAyG,iBAAiB,CAACxG,aAAlB,GAAkC;AAChC5B,EAAAA,WAAW,EAAE,OADmB;AAEhCE,EAAAA,eAAe,EAAE;AAFe,CAAlC;;AAKA,SAASmI,cAAT,CAAwBE,CAAxB,EAA2BD,OAA3B,EAAoC;AAClC,QAAM;AAACrK,IAAAA,KAAD;AAAQC,IAAAA;AAAR,MAAkBoK,OAAxB;AACA,QAAM1L,MAAM,GAAG0L,OAAO,CAACzL,cAAR,CAAuB,IAAvB,CAAf;AACA,QAAM2L,OAAO,GAAGvK,KAAK,GAAG,CAAxB;AACA,QAAMwK,OAAO,GAAGvK,MAAM,GAAG,CAAzB;;AAEA,MAAIsK,OAAO,IAAI,CAAX,IAAgBC,OAAO,IAAI,CAA/B,EAAkC;AAChC,WAAO,KAAP;AACD;;AAED,SAAQnL,IAAI,CAACoL,GAAL,CAASH,CAAC,CAAC/L,CAAF,GAAMI,MAAM,CAACJ,CAAtB,EAAyB,CAAzB,IAA8Bc,IAAI,CAACoL,GAAL,CAASF,OAAT,EAAkB,CAAlB,CAA/B,GAAwDlL,IAAI,CAACoL,GAAL,CAASH,CAAC,CAAC9L,CAAF,GAAMG,MAAM,CAACH,CAAtB,EAAyB,CAAzB,IAA8Ba,IAAI,CAACoL,GAAL,CAASD,OAAT,EAAkB,CAAlB,CAAtF,IAA+G,GAAtH;AACD;;AAED,MAAME,eAAN,SAA8B9P,OAA9B,CAAsC;AAEpC0D,EAAAA,OAAO,CAACC,CAAD,EAAIC,CAAJ,EAAO;AACZ,UAAM;AAACwB,MAAAA,KAAD;AAAQ/D,MAAAA;AAAR,QAAmB,IAAzB;AACA,UAAM0C,MAAM,GAAG,KAAKC,cAAL,CAAoB,IAApB,CAAf;AACA,UAAMsB,MAAM,GAAGF,KAAK,GAAG,CAAR,GAAY/D,OAAO,CAAC4F,WAAnC;;AAEA,QAAI3B,MAAM,IAAI,CAAd,EAAiB;AACf,aAAO,KAAP;AACD;;AAED,WAAQb,IAAI,CAACoL,GAAL,CAASlM,CAAC,GAAGI,MAAM,CAACJ,CAApB,EAAuB,CAAvB,IAA4Bc,IAAI,CAACoL,GAAL,CAASjM,CAAC,GAAGG,MAAM,CAACH,CAApB,EAAuB,CAAvB,CAA7B,IAA2Da,IAAI,CAACoL,GAAL,CAASvK,MAAT,EAAiB,CAAjB,CAAlE;AACD;;AAEDtB,EAAAA,cAAc,CAAC4C,gBAAD,EAAmB;AAC/B,UAAM;AAACjD,MAAAA,CAAD;AAAIC,MAAAA;AAAJ,QAAS,KAAKiD,QAAL,CAAc,CAAC,GAAD,EAAM,GAAN,CAAd,EAA0BD,gBAA1B,CAAf;AACA,WAAO;AAACjD,MAAAA,CAAD;AAAIC,MAAAA;AAAJ,KAAP;AACD;;AAEDkD,EAAAA,IAAI,CAAC3B,GAAD,EAAM;AACR,UAAM;AAACxB,MAAAA,CAAD;AAAIC,MAAAA,CAAJ;AAAOwB,MAAAA,KAAP;AAAc/D,MAAAA;AAAd,QAAyB,IAA/B;AAEA8D,IAAAA,GAAG,CAAC4B,IAAJ;AAEA5B,IAAAA,GAAG,CAAC6B,SAAJ,GAAgB3F,OAAO,CAAC4F,WAAxB;AACA9B,IAAAA,GAAG,CAAC+B,WAAJ,GAAkB7F,OAAO,CAAC8F,WAA1B;AACAhC,IAAAA,GAAG,CAACiC,SAAJ,GAAgB/F,OAAO,CAACgG,eAAxB;AAEAlC,IAAAA,GAAG,CAACmC,WAAJ,CAAgBjG,OAAO,CAACkG,UAAxB;AACApC,IAAAA,GAAG,CAACqC,cAAJ,GAAqBnG,OAAO,CAACoG,gBAA7B;AAEAtC,IAAAA,GAAG,CAACI,SAAJ;AACAJ,IAAAA,GAAG,CAACY,GAAJ,CAAQpC,CAAR,EAAWC,CAAX,EAAcwB,KAAK,GAAG,CAAtB,EAAyB,CAAzB,EAA4BX,IAAI,CAACC,EAAL,GAAU,CAAtC;AACAS,IAAAA,GAAG,CAACwC,IAAJ;AACAxC,IAAAA,GAAG,CAACyC,MAAJ;AAEAzC,IAAAA,GAAG,CAAC0C,OAAJ;AACD;;AAEDC,EAAAA,wBAAwB,CAAC3G,KAAD,EAAQE,OAAR,EAAiB;AACvC,UAAM;AAACiH,MAAAA,SAAD;AAAYN,MAAAA;AAAZ,QAAsB7G,KAA5B;AACA,UAAM4G,MAAM,GAAGC,MAAM,CAAC3G,OAAO,CAAC4G,QAAT,CAArB;AACA,UAAMC,MAAM,GAAGF,MAAM,CAAC3G,OAAO,CAAC8G,QAAT,CAArB;AACA,QAAIxE,CAAC,GAAG2E,SAAS,CAAClD,KAAV,GAAkB,CAA1B;AACA,QAAIxB,CAAC,GAAG0E,SAAS,CAACjD,MAAV,GAAmB,CAA3B;;AAEA,QAAI0C,MAAJ,EAAY;AACVpE,MAAAA,CAAC,GAAGiB,UAAU,CAACmD,MAAD,EAAS1G,OAAO,CAAC0O,MAAjB,EAAyBpM,CAAzB,CAAd;AACD;;AAED,QAAIuE,MAAJ,EAAY;AACVtE,MAAAA,CAAC,GAAGgB,UAAU,CAACsD,MAAD,EAAS7G,OAAO,CAAC2O,MAAjB,EAAyBpM,CAAzB,CAAd;AACD;;AAED,WAAO;AACLD,MAAAA,CADK;AAELC,MAAAA,CAFK;AAGLwB,MAAAA,KAAK,EAAE/D,OAAO,CAACiE,MAAR,GAAiB,CAHnB;AAILD,MAAAA,MAAM,EAAEhE,OAAO,CAACiE,MAAR,GAAiB;AAJpB,KAAP;AAMD;;AA5DmC;;AA+DtCwK,eAAe,CAAClH,EAAhB,GAAqB,iBAArB;AAEAkH,eAAe,CAAC5P,QAAhB,GAA2B;AACzBuD,EAAAA,OAAO,EAAE,IADgB;AAEzBoF,EAAAA,gBAAgB,EAAE,IAFO;AAGzBtB,EAAAA,UAAU,EAAE,EAHa;AAIzBE,EAAAA,gBAAgB,EAAE,CAJO;AAKzBR,EAAAA,WAAW,EAAE,CALY;AAMzB3B,EAAAA,MAAM,EAAE,EANiB;AAOzB2C,EAAAA,QAAQ,EAAE,GAPe;AAQzB8H,EAAAA,MAAM,EAAEjH,SARiB;AASzBX,EAAAA,QAAQ,EAAE,GATe;AAUzB6H,EAAAA,MAAM,EAAElH;AAViB,CAA3B;AAaAgH,eAAe,CAAC/G,aAAhB,GAAgC;AAC9B5B,EAAAA,WAAW,EAAE,OADiB;AAE9BE,EAAAA,eAAe,EAAE;AAFa,CAAhC;AAKA,IAAI4I,OAAO,GAAG,OAAd;AAEA,MAAMC,WAAW,GAAG,IAAIxC,GAAJ,EAApB;AAEA,MAAMyC,eAAe,GAAG;AACtBC,EAAAA,GAAG,EAAE3J,aADiB;AAEtBiG,EAAAA,IAAI,EAAExC,cAFgB;AAGtBuF,EAAAA,OAAO,EAAEF,iBAHa;AAItBpJ,EAAAA,KAAK,EAAE2J;AAJe,CAAxB;AAOAO,MAAM,CAACC,IAAP,CAAYH,eAAZ,EAA6B1O,OAA7B,CAAqC8O,GAAG,IAAI;AAC1CrQ,EAAAA,QAAQ,CAACsQ,QAAT,CAAmB,YAAWL,eAAe,CAACI,GAAD,CAAf,CAAqB3H,EAAG,EAAtD,EAAyD;AACvD6H,IAAAA,SAAS,EAAE;AAD4C,GAAzD;AAGD,CAJD;AAMA,IAAIC,UAAU,GAAG;AACf9H,EAAAA,EAAE,EAAE,YADW;AAGfqH,EAAAA,OAHe;;AAKfU,EAAAA,aAAa,GAAG;AACd1Q,IAAAA,KAAK,CAAC2Q,QAAN,CAAeT,eAAf;AACD,GAPc;;AASfU,EAAAA,eAAe,GAAG;AAChB5Q,IAAAA,KAAK,CAAC6Q,UAAN,CAAiBX,eAAjB;AACD,GAXc;;AAafY,EAAAA,UAAU,CAAC5P,KAAD,EAAQ;AAChB+O,IAAAA,WAAW,CAACnC,GAAZ,CAAgB5M,KAAhB,EAAuB;AACrBG,MAAAA,WAAW,EAAE,EADQ;AAErBc,MAAAA,QAAQ,EAAE,EAFW;AAGrBT,MAAAA,SAAS,EAAE,EAHU;AAIrBJ,MAAAA,QAAQ,EAAE,KAJW;AAKrBC,MAAAA,YAAY,EAAE;AALO,KAAvB;AAOD,GArBc;;AAuBfwP,EAAAA,YAAY,CAAC7P,KAAD,EAAQ8P,IAAR,EAAc5P,OAAd,EAAuB;AACjC,UAAMD,KAAK,GAAG8O,WAAW,CAACjC,GAAZ,CAAgB9M,KAAhB,CAAd;AACA,UAAMG,WAAW,GAAGF,KAAK,CAACE,WAAN,GAAoB,EAAxC;AAEA,QAAI4P,iBAAiB,GAAG7P,OAAO,CAACC,WAAhC;;AACA,QAAIZ,QAAQ,CAACwQ,iBAAD,CAAZ,EAAiC;AAC/Bb,MAAAA,MAAM,CAACC,IAAP,CAAYY,iBAAZ,EAA+BzP,OAA/B,CAAuC8O,GAAG,IAAI;AAC5C,cAAMzL,KAAK,GAAGoM,iBAAiB,CAACX,GAAD,CAA/B;;AACA,YAAI7P,QAAQ,CAACoE,KAAD,CAAZ,EAAqB;AACnBA,UAAAA,KAAK,CAAC8D,EAAN,GAAW2H,GAAX;AACAjP,UAAAA,WAAW,CAAC4C,IAAZ,CAAiBY,KAAjB;AACD;AACF,OAND;AAOD,KARD,MAQO,IAAItE,OAAO,CAAC0Q,iBAAD,CAAX,EAAgC;AACrC5P,MAAAA,WAAW,CAAC4C,IAAZ,CAAiB,GAAGgN,iBAApB;AACD;AACF,GAvCc;;AAyCfC,EAAAA,eAAe,CAAChQ,KAAD,EAAQ8P,IAAR,EAAc;AAC3B,UAAM7P,KAAK,GAAG8O,WAAW,CAACjC,GAAZ,CAAgB9M,KAAhB,CAAd;AACA0H,IAAAA,gBAAgB,CAAC1H,KAAD,EAAQ8P,IAAI,CAACpM,KAAb,EAAoBzD,KAAK,CAACE,WAAN,CAAkBkC,MAAlB,CAAyBY,CAAC,IAAIA,CAAC,CAACX,OAAF,IAAaW,CAAC,CAACyE,gBAA7C,CAApB,CAAhB;AACD,GA5Cc;;AA8CfuI,EAAAA,WAAW,CAACjQ,KAAD,EAAQ8P,IAAR,EAAc5P,OAAd,EAAuB;AAChC,UAAMD,KAAK,GAAG8O,WAAW,CAACjC,GAAZ,CAAgB9M,KAAhB,CAAd;AACAD,IAAAA,eAAe,CAACC,KAAD,EAAQC,KAAR,EAAeC,OAAf,CAAf;AACAgQ,IAAAA,cAAc,CAAClQ,KAAD,EAAQC,KAAR,EAAeC,OAAf,EAAwB4P,IAAI,CAACK,IAA7B,CAAd;AACD,GAlDc;;AAoDfC,EAAAA,kBAAkB,CAACpQ,KAAD,EAAQ;AACxB2F,IAAAA,IAAI,CAAC3F,KAAD,EAAQ,oBAAR,CAAJ;AACD,GAtDc;;AAwDfqQ,EAAAA,iBAAiB,CAACrQ,KAAD,EAAQ;AACvB2F,IAAAA,IAAI,CAAC3F,KAAD,EAAQ,mBAAR,CAAJ;AACD,GA1Dc;;AA4DfsQ,EAAAA,UAAU,CAACtQ,KAAD,EAAQ;AAChB2F,IAAAA,IAAI,CAAC3F,KAAD,EAAQ,YAAR,CAAJ;AACD,GA9Dc;;AAgEfuQ,EAAAA,SAAS,CAACvQ,KAAD,EAAQ;AACf2F,IAAAA,IAAI,CAAC3F,KAAD,EAAQ,WAAR,CAAJ;AACD,GAlEc;;AAoEfwQ,EAAAA,WAAW,CAACxQ,KAAD,EAAQ8P,IAAR,EAAc5P,OAAd,EAAuB;AAChC,UAAMD,KAAK,GAAG8O,WAAW,CAACjC,GAAZ,CAAgB9M,KAAhB,CAAd;AACAU,IAAAA,WAAW,CAACV,KAAD,EAAQC,KAAR,EAAe6P,IAAI,CAACnP,KAApB,EAA2BT,OAA3B,CAAX;AACD,GAvEc;;AAyEfuQ,EAAAA,OAAO,CAACzQ,KAAD,EAAQ;AACb+O,IAAAA,WAAW,CAAC2B,MAAZ,CAAmB1Q,KAAnB;AACD,GA3Ec;;AA6Ef2Q,EAAAA,SAAS,CAAC3Q,KAAD,EAAQ;AACf,WAAO+O,WAAW,CAACjC,GAAZ,CAAgB9M,KAAhB,CAAP;AACD,GA/Ec;;AAiFfjB,EAAAA,QAAQ,EAAE;AACR0L,IAAAA,QAAQ,EAAE,mBADF;AAER3I,IAAAA,aAAa,EAAE,GAFP;AAEY;AACpB8O,IAAAA,UAAU,EAAE;AACVC,MAAAA,OAAO,EAAE;AACPC,QAAAA,UAAU,EAAE,CAAC,GAAD,EAAM,GAAN,EAAW,IAAX,EAAiB,IAAjB,EAAuB,OAAvB,EAAgC,QAAhC,CADL;AAEPlQ,QAAAA,IAAI,EAAE;AAFC;AADC,KAHJ;AASRgJ,IAAAA,KAAK,EAAE;AACLa,MAAAA,QAAQ,EAAE;AADL;AATC,GAjFK;AA+FfsG,EAAAA,WAAW,EAAE;AACXC,IAAAA,UAAU,EAAE,KADD;AAEXC,IAAAA,WAAW,EAAGC,IAAD,IAAU,CAACrR,KAAK,CAACsR,QAAN,CAAeD,IAAf,CAFb;AAGX/Q,IAAAA,WAAW,EAAE;AACXiR,MAAAA,QAAQ,EAAE,KADC;AAEX9B,MAAAA,SAAS,EAAE,CAAC4B,IAAD,EAAOG,IAAP,KAAiB,YAAWrC,eAAe,CAACqC,IAAI,CAACzQ,IAAL,IAAa,MAAd,CAAf,CAAqC6G,EAAG;AAFpE;AAHF,GA/FE;AAwGf6J,EAAAA,sBAAsB,EAAE,CAAC,EAAD;AAxGT,CAAjB;AA2GA,MAAMC,aAAa,GAAG;AACpBC,EAAAA,MAAM,EAAEtC,MAAM,CAACuC;AADK,CAAtB;;AAIA,SAASC,iBAAT,CAA2B1R,KAA3B,EAAkC2R,QAAlC,EAA4CxB,IAA5C,EAAkD;AAChD,MAAIA,IAAI,KAAK,OAAT,IAAoBA,IAAI,KAAK,MAA7B,IAAuCA,IAAI,KAAK,QAApD,EAA8D;AAC5D,WAAOoB,aAAP;AACD;;AACD,SAAO,IAAIvS,UAAJ,CAAegB,KAAf,EAAsB2R,QAAtB,CAAP;AACD;;AAED,SAASzB,cAAT,CAAwBlQ,KAAxB,EAA+BC,KAA/B,EAAsCC,OAAtC,EAA+CiQ,IAA/C,EAAqD;AACnD,QAAMS,UAAU,GAAGc,iBAAiB,CAAC1R,KAAD,EAAQE,OAAO,CAAC0Q,UAAhB,EAA4BT,IAA5B,CAApC;AAEA,QAAMhQ,WAAW,GAAGF,KAAK,CAACE,WAA1B;AACA,QAAMc,QAAQ,GAAG2Q,cAAc,CAAC3R,KAAK,CAACgB,QAAP,EAAiBd,WAAjB,CAA/B;;AAEA,OAAK,IAAI4L,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG5L,WAAW,CAAC6L,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;AAC3C,UAAMwD,UAAU,GAAGpP,WAAW,CAAC4L,CAAD,CAA9B;AACA,QAAI8F,EAAE,GAAG5Q,QAAQ,CAAC8K,CAAD,CAAjB;AACA,UAAM+F,MAAM,GAAG9C,eAAe,CAACO,UAAU,CAAC3O,IAAZ,CAAf,IAAoCoO,eAAe,CAACzD,IAAnE;;AACA,QAAI,CAACsG,EAAD,IAAO,EAAEA,EAAE,YAAYC,MAAhB,CAAX,EAAoC;AAClCD,MAAAA,EAAE,GAAG5Q,QAAQ,CAAC8K,CAAD,CAAR,GAAc,IAAI+F,MAAJ,EAAnB;AACD;;AACD,UAAMT,IAAI,GAAGU,wBAAwB,CAACxC,UAAU,CAACyC,UAAX,CAAsBC,UAAU,CAACjS,KAAD,EAAQ6R,EAAR,EAAYtC,UAAZ,CAAhC,CAAD,CAArC;AACA,UAAMuB,UAAU,GAAGe,EAAE,CAAClL,wBAAH,CAA4B3G,KAA5B,EAAmCqR,IAAnC,CAAnB;AACAP,IAAAA,UAAU,CAACoB,IAAX,GAAkBC,KAAK,CAACrB,UAAU,CAACtO,CAAZ,CAAL,IAAuB2P,KAAK,CAACrB,UAAU,CAACrO,CAAZ,CAA9C;AACAqO,IAAAA,UAAU,CAAC5Q,OAAX,GAAqBmR,IAArB;AACAT,IAAAA,UAAU,CAACY,MAAX,CAAkBK,EAAlB,EAAsBf,UAAtB;AACD;AACF;;AAED,SAASiB,wBAAT,CAAkCK,QAAlC,EAA4C;AAC1C,QAAMN,MAAM,GAAG9C,eAAe,CAACoD,QAAQ,CAACxR,IAAV,CAAf,IAAkCoO,eAAe,CAACzD,IAAjE;AACA,QAAM8G,MAAM,GAAG,EAAf;AACAA,EAAAA,MAAM,CAAC5K,EAAP,GAAY2K,QAAQ,CAAC3K,EAArB;AACA4K,EAAAA,MAAM,CAACzR,IAAP,GAAcwR,QAAQ,CAACxR,IAAvB;AACAyR,EAAAA,MAAM,CAAC5H,QAAP,GAAkB2H,QAAQ,CAAC3H,QAA3B;AACAyE,EAAAA,MAAM,CAACuC,MAAP,CAAcY,MAAd,EAAsBC,UAAU,CAACF,QAAD,EAAWN,MAAM,CAAC/S,QAAlB,CAAhC,EAA6DuT,UAAU,CAACF,QAAD,EAAWN,MAAM,CAAClK,aAAlB,CAAvE;;AACA,OAAK,MAAMrH,IAAX,IAAmBV,KAAnB,EAA0B;AACxBwS,IAAAA,MAAM,CAAC9R,IAAD,CAAN,GAAe6R,QAAQ,CAAC7R,IAAD,CAAvB;AACD;;AACD,SAAO8R,MAAP;AACD;;AAED,SAASC,UAAT,CAAoBF,QAApB,EAA8BG,IAA9B,EAAoC;AAClC,QAAMF,MAAM,GAAG,EAAf;;AACA,OAAK,MAAMG,IAAX,IAAmBtD,MAAM,CAACC,IAAP,CAAYoD,IAAZ,CAAnB,EAAsC;AACpC,UAAME,OAAO,GAAGF,IAAI,CAACC,IAAD,CAApB;AACA,UAAM7O,KAAK,GAAGyO,QAAQ,CAACI,IAAD,CAAtB;AACAH,IAAAA,MAAM,CAACG,IAAD,CAAN,GAAejT,QAAQ,CAACkT,OAAD,CAAR,GAAoBH,UAAU,CAAC3O,KAAD,EAAQ8O,OAAR,CAA9B,GAAiD9O,KAAhE;AACD;;AACD,SAAO0O,MAAP;AACD;;AAED,SAASJ,UAAT,CAAoBjS,KAApB,EAA2Be,OAA3B,EAAoCwO,UAApC,EAAgD;AAC9C,SAAOxO,OAAO,CAAC2R,QAAR,KAAqB3R,OAAO,CAAC2R,QAAR,GAAmBxD,MAAM,CAACuC,MAAP,CAAcvC,MAAM,CAACyD,MAAP,CAAc3S,KAAK,CAACiS,UAAN,EAAd,CAAd,EAAiD;AAC9FlR,IAAAA,OAD8F;AAE9F0G,IAAAA,EAAE,EAAE8H,UAAU,CAAC9H,EAF+E;AAG9F7G,IAAAA,IAAI,EAAE;AAHwF,GAAjD,CAAxC,CAAP;AAKD;;AAED,SAASgR,cAAT,CAAwB3Q,QAAxB,EAAkCd,WAAlC,EAA+C;AAC7C,QAAMsM,KAAK,GAAGtM,WAAW,CAAC6L,MAA1B;AACA,QAAM4G,KAAK,GAAG3R,QAAQ,CAAC+K,MAAvB;;AAEA,MAAI4G,KAAK,GAAGnG,KAAZ,EAAmB;AACjB,UAAMoG,GAAG,GAAGpG,KAAK,GAAGmG,KAApB;AACA3R,IAAAA,QAAQ,CAAC6R,MAAT,CAAgBF,KAAhB,EAAuB,CAAvB,EAA0B,GAAG,IAAIG,KAAJ,CAAUF,GAAV,CAA7B;AACD,GAHD,MAGO,IAAID,KAAK,GAAGnG,KAAZ,EAAmB;AACxBxL,IAAAA,QAAQ,CAAC6R,MAAT,CAAgBrG,KAAhB,EAAuBmG,KAAK,GAAGnG,KAA/B;AACD;;AACD,SAAOxL,QAAP;AACD;;AAED,SAAS0E,IAAT,CAAc3F,KAAd,EAAqBgT,MAArB,EAA6B;AAC3B,QAAM;AAAChP,IAAAA,GAAD;AAAMmD,IAAAA;AAAN,MAAmBnH,KAAzB;AACA,QAAMC,KAAK,GAAG8O,WAAW,CAACjC,GAAZ,CAAgB9M,KAAhB,CAAd;AACA,QAAMiB,QAAQ,GAAGhB,KAAK,CAACgB,QAAN,CAAeoB,MAAf,CAAsBwP,EAAE,IAAI,CAACA,EAAE,CAACK,IAAJ,IAAYL,EAAE,CAAC3R,OAAH,CAAWoC,OAAnD,CAAjB;AAEA9C,EAAAA,QAAQ,CAACwE,GAAD,EAAMmD,SAAN,CAAR;AACAlG,EAAAA,QAAQ,CAACX,OAAT,CAAiBuR,EAAE,IAAI;AACrB,QAAIA,EAAE,CAAC3R,OAAH,CAAWuK,QAAX,KAAwBuI,MAA5B,EAAoC;AAClCnB,MAAAA,EAAE,CAAClM,IAAH,CAAQ3B,GAAR;AACD;AACF,GAJD;AAKAvE,EAAAA,UAAU,CAACuE,GAAD,CAAV;AAEA/C,EAAAA,QAAQ,CAACX,OAAT,CAAiBuR,EAAE,IAAI;AACrB,QAAI,eAAeA,EAAf,IAAqBA,EAAE,CAAC3R,OAAH,CAAW0J,KAAhC,IAAyC,CAACiI,EAAE,CAAC3R,OAAH,CAAW0J,KAAX,CAAiBa,QAAjB,IAA6BoH,EAAE,CAAC3R,OAAH,CAAWuK,QAAzC,MAAuDuI,MAApG,EAA4G;AAC1GnB,MAAAA,EAAE,CAACxH,SAAH,CAAarG,GAAb,EAAkBmD,SAAlB;AACD;AACF,GAJD;AAKD;;AAED,SAASO,gBAAT,CAA0B1H,KAA1B,EAAiC0D,KAAjC,EAAwCvD,WAAxC,EAAqD;AACnD,QAAM8S,KAAK,GAAGC,cAAc,CAACxP,KAAD,EAAQvD,WAAR,CAA5B;AACA,MAAIgT,OAAO,GAAG,KAAd;;AACA,MAAIhU,QAAQ,CAAC8T,KAAK,CAAC3O,GAAP,CAAR,IACJ,OAAOZ,KAAK,CAACxD,OAAN,CAAcoE,GAArB,KAA6B,WADzB,IAEJ,OAAOZ,KAAK,CAACxD,OAAN,CAAckT,YAArB,KAAsC,WAFtC,EAEmD;AACjDD,IAAAA,OAAO,GAAGzP,KAAK,CAACY,GAAN,KAAc2O,KAAK,CAAC3O,GAA9B;AACAZ,IAAAA,KAAK,CAACY,GAAN,GAAY2O,KAAK,CAAC3O,GAAlB;AACD;;AACD,MAAInF,QAAQ,CAAC8T,KAAK,CAAC7L,GAAP,CAAR,IACJ,OAAO1D,KAAK,CAACxD,OAAN,CAAckH,GAArB,KAA6B,WADzB,IAEJ,OAAO1D,KAAK,CAACxD,OAAN,CAAcmT,YAArB,KAAsC,WAFtC,EAEmD;AACjDF,IAAAA,OAAO,GAAGzP,KAAK,CAAC0D,GAAN,KAAc6L,KAAK,CAAC7L,GAA9B;AACA1D,IAAAA,KAAK,CAAC0D,GAAN,GAAY6L,KAAK,CAAC7L,GAAlB;AACD;;AACD,MAAI+L,OAAO,IAAI,OAAOzP,KAAK,CAAC4P,sBAAb,KAAwC,UAAvD,EAAmE;AACjE5P,IAAAA,KAAK,CAAC4P,sBAAN;AACD;AACF;;AAED,SAASJ,cAAT,CAAwBxP,KAAxB,EAA+BvD,WAA/B,EAA4C;AAC1C,QAAMoT,IAAI,GAAG7P,KAAK,CAAC6P,IAAnB;AACA,QAAMjJ,OAAO,GAAG5G,KAAK,CAAC+D,EAAtB;AACA,QAAM+L,aAAa,GAAGD,IAAI,GAAG,SAA7B;AACA,MAAIjP,GAAG,GAAG5E,cAAc,CAACgE,KAAK,CAACY,GAAP,EAAYnC,MAAM,CAACsR,iBAAnB,CAAxB;AACA,MAAIrM,GAAG,GAAG1H,cAAc,CAACgE,KAAK,CAAC0D,GAAP,EAAYjF,MAAM,CAACC,iBAAnB,CAAxB;;AACA,OAAK,MAAMmN,UAAX,IAAyBpP,WAAzB,EAAsC;AACpC,QAAIoP,UAAU,CAACjF,OAAX,KAAuBA,OAA3B,EAAoC;AAClC,WAAK,MAAM4G,IAAX,IAAmB,CAAC,OAAD,EAAU,UAAV,CAAnB,EAA0C;AACxC,cAAMwC,GAAG,GAAGnE,UAAU,CAAC2B,IAAD,CAAtB;;AACA,YAAIwC,GAAJ,EAAS;AACP,gBAAM/P,KAAK,GAAGD,KAAK,CAACG,KAAN,CAAY6P,GAAZ,CAAd;AACApP,UAAAA,GAAG,GAAGhB,IAAI,CAACgB,GAAL,CAASA,GAAT,EAAcX,KAAd,CAAN;AACAyD,UAAAA,GAAG,GAAG9D,IAAI,CAAC8D,GAAL,CAASA,GAAT,EAAczD,KAAd,CAAN;AACD;AACF;AACF,KATD,MASO,IAAI4L,UAAU,CAACiE,aAAD,CAAV,KAA8BlJ,OAAlC,EAA2C;AAChD,WAAK,MAAM4G,IAAX,IAAmB,CAACqC,IAAI,GAAG,KAAR,EAAeA,IAAI,GAAG,KAAtB,EAA6BA,IAAI,GAAG,OAApC,CAAnB,EAAiE;AAC/D,cAAMG,GAAG,GAAGnE,UAAU,CAAC2B,IAAD,CAAtB;;AACA,YAAIwC,GAAJ,EAAS;AACP,gBAAM/P,KAAK,GAAGD,KAAK,CAACG,KAAN,CAAY6P,GAAZ,CAAd;AACApP,UAAAA,GAAG,GAAGhB,IAAI,CAACgB,GAAL,CAASA,GAAT,EAAcX,KAAd,CAAN;AACAyD,UAAAA,GAAG,GAAG9D,IAAI,CAAC8D,GAAL,CAASA,GAAT,EAAczD,KAAd,CAAN;AACD;AACF;AACF;AACF;;AACD,SAAO;AAACW,IAAAA,GAAD;AAAM8C,IAAAA;AAAN,GAAP;AACD;;AAED,eAAemI,UAAf","sourcesContent":["/*!\n* chartjs-plugin-annotation v1.0.2\n* https://www.chartjs.org/chartjs-plugin-annotation/index\n * (c) 2021 chartjs-plugin-annotation Contributors\n * Released under the MIT License\n */\nimport { Element, Chart, defaults, Animations } from 'chart.js';\nimport { distanceBetweenPoints, callback, isFinite, toFontString, isArray, toRadians, isObject, clipArea, unclipArea, valueOrDefault } from 'chart.js/helpers';\n\nconst clickHooks = ['click', 'dblclick'];\nconst moveHooks = ['enter', 'leave'];\nconst hooks = clickHooks.concat(moveHooks);\n\nfunction updateListeners(chart, state, options) {\n  const annotations = state.annotations || [];\n  state.listened = false;\n  state.moveListened = false;\n\n  hooks.forEach(hook => {\n    if (typeof options[hook] === 'function') {\n      state.listened = true;\n      state.listeners[hook] = options[hook];\n    }\n  });\n  moveHooks.forEach(hook => {\n    if (typeof options[hook] === 'function') {\n      state.moveListened = true;\n    }\n  });\n\n  if (!state.listened || !state.moveListened) {\n    annotations.forEach(scope => {\n      if (!state.listened) {\n        clickHooks.forEach(hook => {\n          if (typeof scope[hook] === 'function') {\n            state.listened = true;\n          }\n        });\n      }\n      if (!state.moveListened) {\n        moveHooks.forEach(hook => {\n          if (typeof scope[hook] === 'function') {\n            state.listened = true;\n            state.moveListened = true;\n          }\n        });\n      }\n    });\n  }\n}\n\nfunction handleEvent(chart, state, event, options) {\n  if (state.listened) {\n    switch (event.type) {\n    case 'mousemove':\n    case 'mouseout':\n      handleMoveEvents(chart, state, event);\n      break;\n    case 'click':\n      handleClickEvents(chart, state, event, options);\n      break;\n    }\n  }\n}\n\nfunction handleMoveEvents(chart, state, event) {\n  if (!state.moveListened) {\n    return;\n  }\n\n  let element;\n\n  if (event.type === 'mousemove') {\n    element = getNearestItem(state.elements, event);\n  }\n\n  const previous = state.hovered;\n  state.hovered = element;\n\n  dispatchMoveEvents(chart, state, previous, element);\n}\n\nfunction dispatchMoveEvents(chart, state, previous, element) {\n  if (previous && previous !== element) {\n    dispatchEvent(chart, state, previous.options.leave || state.listeners.leave, previous);\n  }\n  if (element && element !== previous) {\n    dispatchEvent(chart, state, element.options.enter || state.listeners.enter, element);\n  }\n}\n\nfunction handleClickEvents(chart, state, event, options) {\n  const listeners = state.listeners;\n  const element = getNearestItem(state.elements, event);\n  if (element) {\n    const elOpts = element.options;\n    const dblclick = elOpts.dblclick || listeners.dblclick;\n    const click = elOpts.click || listeners.click;\n    if (element.clickTimeout) {\n      // 2nd click before timeout, so its a double click\n      clearTimeout(element.clickTimeout);\n      delete element.clickTimeout;\n      dispatchEvent(chart, state, dblclick, element);\n    } else if (dblclick) {\n      // if there is a dblclick handler, wait for dblClickSpeed ms before deciding its a click\n      element.clickTimeout = setTimeout(() => {\n        delete element.clickTimeout;\n        dispatchEvent(chart, state, click, element);\n      }, options.dblClickSpeed);\n    } else {\n      // no double click handler, just call the click handler directly\n      dispatchEvent(chart, state, click, element);\n    }\n  }\n}\n\nfunction dispatchEvent(chart, _state, handler, element) {\n  callback(handler, [{chart, element}]);\n}\n\nfunction getNearestItem(elements, position) {\n  let minDistance = Number.POSITIVE_INFINITY;\n\n  return elements\n    .filter((element) => element.options.display && element.inRange(position.x, position.y))\n    .reduce((nearestItems, element) => {\n      const center = element.getCenterPoint();\n      const distance = distanceBetweenPoints(position, center);\n\n      if (distance < minDistance) {\n        nearestItems = [element];\n        minDistance = distance;\n      } else if (distance === minDistance) {\n        // Can have multiple items at the same distance in which case we sort by size\n        nearestItems.push(element);\n      }\n\n      return nearestItems;\n    }, [])\n    .sort((a, b) => a._index - b._index)\n    .slice(0, 1)[0]; // return only the top item\n}\n\nconst PI$1 = Math.PI;\nconst HALF_PI = PI$1 / 2;\n\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ? scale.getPixelForValue(value) : fallback;\n}\n\n/**\n * Creates a \"path\" for a rectangle with rounded corners at position (x, y) with a\n * given size (width, height) and the same `radius` for all corners.\n * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.\n * @param {number} x - The x axis of the coordinate for the rectangle starting point.\n * @param {number} y - The y axis of the coordinate for the rectangle starting point.\n * @param {number} width - The rectangle's width.\n * @param {number} height - The rectangle's height.\n * @param {number} radius - The rounded amount (in pixels) for the four corners.\n * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?\n */\nfunction roundedRect(ctx, x, y, width, height, radius) {\n  ctx.beginPath();\n  if (radius) {\n    const r = Math.min(radius, height / 2, width / 2);\n    const left = x + r;\n    const top = y + r;\n    const right = x + width - r;\n    const bottom = y + height - r;\n\n    ctx.moveTo(x, top);\n    if (left < right && top < bottom) {\n      ctx.arc(left, top, r, -PI$1, -HALF_PI);\n      ctx.arc(right, top, r, -HALF_PI, 0);\n      ctx.arc(right, bottom, r, 0, HALF_PI);\n      ctx.arc(left, bottom, r, HALF_PI, PI$1);\n    } else if (left < right) {\n      ctx.moveTo(left, y);\n      ctx.arc(right, top, r, -HALF_PI, HALF_PI);\n      ctx.arc(left, top, r, HALF_PI, PI$1 + HALF_PI);\n    } else if (top < bottom) {\n      ctx.arc(left, top, r, -PI$1, 0);\n      ctx.arc(left, bottom, r, 0, PI$1);\n    } else {\n      ctx.arc(left, top, r, -PI$1, PI$1);\n    }\n    ctx.closePath();\n    ctx.moveTo(x, y);\n  } else {\n    ctx.rect(x, y, width, height);\n  }\n}\n\n/**\n * Rotate a `point` relative to `center` point by `angle`\n * @param {{x: number, y: number}} point - the point to rotate\n * @param {{x: number, y: number}} center - center point for rotation\n * @param {number} angle - angle for rotation, in radians\n * @returns {{x: number, y: number}} rotated point\n */\nfunction rotated(point, center, angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  var cx = center.x;\n  var cy = center.y;\n\n  return {\n    x: cx + cos * (point.x - cx) - sin * (point.y - cy),\n    y: cy + sin * (point.x - cx) + cos * (point.y - cy)\n  };\n}\n\nclass BoxAnnotation extends Element {\n  inRange(mouseX, mouseY, useFinalPosition) {\n    const {x, y, width, height} = this.getProps(['x', 'y', 'width', 'height'], useFinalPosition);\n\n    return mouseX >= x &&\n\t\t\tmouseX <= x + width &&\n\t\t\tmouseY >= y &&\n\t\t\tmouseY <= y + height;\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {x, y, width, height} = this.getProps(['x', 'y', 'width', 'height'], useFinalPosition);\n    return {\n      x: x + width / 2,\n      y: y + height / 2\n    };\n  }\n\n  draw(ctx) {\n    const {x, y, width, height, options} = this;\n\n    ctx.save();\n\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.fillStyle = options.backgroundColor;\n\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n\n    roundedRect(ctx, x, y, width, height, options.cornerRadius);\n    ctx.fill();\n\n    // If no border, don't draw it\n    if (options.borderWidth) {\n      ctx.stroke();\n    }\n\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    const xScale = chart.scales[options.xScaleID];\n    const yScale = chart.scales[options.yScaleID];\n    let {top: y, left: x, bottom: y2, right: x2} = chart.chartArea;\n    let min, max;\n\n    if (!xScale && !yScale) {\n      return {options: {}};\n    }\n\n    if (xScale) {\n      min = scaleValue(xScale, options.xMin, x);\n      max = scaleValue(xScale, options.xMax, x2);\n      x = Math.min(min, max);\n      x2 = Math.max(min, max);\n    }\n\n    if (yScale) {\n      min = scaleValue(yScale, options.yMin, y2);\n      max = scaleValue(yScale, options.yMax, y);\n      y = Math.min(min, max);\n      y2 = Math.max(min, max);\n    }\n\n    return {\n      x,\n      y,\n      x2,\n      y2,\n      width: x2 - x,\n      height: y2 - y\n    };\n  }\n}\n\nBoxAnnotation.id = 'boxAnnotation';\n\nBoxAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderDash: [],\n  borderDashOffset: 0,\n  borderWidth: 1,\n  cornerRadius: 0,\n  xScaleID: 'x',\n  xMin: undefined,\n  xMax: undefined,\n  yScaleID: 'y',\n  yMin: undefined,\n  yMax: undefined\n};\n\nBoxAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nconst PI = Math.PI;\nconst clamp = (x, from, to) => Math.min(to, Math.max(from, x));\nconst pointInLine = (p1, p2, t) => ({x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y)});\nconst interpolateX = (y, p1, p2) => pointInLine(p1, p2, Math.abs((y - p1.y) / (p2.y - p1.y))).x;\nconst interpolateY = (x, p1, p2) => pointInLine(p1, p2, Math.abs((x - p1.x) / (p2.x - p1.x))).y;\nconst toPercent = (s) => typeof s === 'string' && s.endsWith('%') && parseFloat(s) / 100;\n\nfunction limitPointToArea({x, y}, p2, {top, right, bottom, left}) {\n  if (x < left) {\n    y = p2.x < left ? NaN : interpolateY(left, {x, y}, p2);\n    x = left;\n  }\n  if (x > right) {\n    y = p2.x > right ? NaN : interpolateY(right, {x, y}, p2);\n    x = right;\n  }\n  if (y < top) {\n    x = p2.y < top ? NaN : interpolateX(top, {x, y}, p2);\n    y = top;\n  }\n  if (y > bottom) {\n    x = p2.y > bottom ? NaN : interpolateX(bottom, {x, y}, p2);\n    y = bottom;\n  }\n  return {x, y};\n}\n\nfunction limitLineToArea(p1, p2, area) {\n  const {x, y} = limitPointToArea(p1, p2, area);\n  const {x: x2, y: y2} = limitPointToArea(p2, p1, area);\n  return {x, y, x2, y2, width: Math.abs(x2 - x), height: Math.abs(y2 - y)};\n}\n\nclass LineAnnotation extends Element {\n  intersects(x, y, epsilon = 0.001) {\n    // Adapted from https://stackoverflow.com/a/6853926/25507\n    const sqr = v => v * v;\n    const {x: x1, y: y1, x2, y2} = this;\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const lenSq = sqr(dx) + sqr(dy);\n    const t = lenSq === 0 ? -1 : ((x - x1) * dx + (y - y1) * dy) / lenSq;\n    let xx, yy;\n    if (t < 0) {\n      xx = x1;\n      yy = y1;\n    } else if (t > 1) {\n      xx = x2;\n      yy = y2;\n    } else {\n      xx = x1 + t * dx;\n      yy = y1 + t * dy;\n    }\n    return (sqr(x - xx) + sqr(y - yy)) < epsilon;\n  }\n\n  labelIsVisible() {\n    const label = this.options.label;\n    return label && label.enabled && label.content;\n  }\n\n  isOnLabel(mouseX, mouseY) {\n    const {labelRect} = this;\n    if (!labelRect || !this.labelIsVisible()) {\n      return false;\n    }\n\n    const {x, y} = rotated({x: mouseX, y: mouseY}, labelRect, -labelRect.rotation);\n    const w2 = labelRect.width / 2;\n    const h2 = labelRect.height / 2;\n    return x >= labelRect.x - w2 && x <= labelRect.x + w2 &&\n      y >= labelRect.y - h2 && y <= labelRect.y + h2;\n  }\n\n  inRange(x, y) {\n    const epsilon = this.options.borderWidth || 1;\n    return this.intersects(x, y, epsilon) || this.isOnLabel(x, y);\n  }\n\n  getCenterPoint() {\n    return {\n      x: (this.x2 + this.x) / 2,\n      y: (this.y2 + this.y) / 2\n    };\n  }\n\n  draw(ctx) {\n    const {x, y, x2, y2, options} = this;\n    ctx.save();\n\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n\n    // Draw\n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  drawLabel(ctx, chartArea) {\n    if (this.labelIsVisible()) {\n      ctx.save();\n      drawLabel(ctx, this, chartArea);\n      ctx.restore();\n    }\n  }\n\n  resolveElementProperties(chart, options) {\n    const scale = chart.scales[options.scaleID];\n    let {top: y, left: x, bottom: y2, right: x2} = chart.chartArea;\n    let min, max;\n\n    if (scale) {\n      min = scaleValue(scale, options.value, NaN);\n      max = scaleValue(scale, options.endValue, min);\n      if (scale.isHorizontal()) {\n        x = min;\n        x2 = max;\n      } else {\n        y = min;\n        y2 = max;\n      }\n    } else {\n      const xScale = chart.scales[options.xScaleID];\n      const yScale = chart.scales[options.yScaleID];\n\n      if (xScale) {\n        x = scaleValue(xScale, options.xMin, x);\n        x2 = scaleValue(xScale, options.xMax, x2);\n      }\n\n      if (yScale) {\n        y = scaleValue(yScale, options.yMin, y);\n        y2 = scaleValue(yScale, options.yMax, y2);\n      }\n    }\n    return limitLineToArea({x, y}, {x: x2, y: y2}, chart.chartArea);\n  }\n}\n\nLineAnnotation.id = 'lineAnnotation';\nLineAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderWidth: 2,\n  borderDash: [],\n  borderDashOffset: 0,\n  label: {\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    drawTime: undefined,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: 'bold',\n      weight: undefined\n    },\n    color: '#fff',\n    xPadding: 6,\n    yPadding: 6,\n    rotation: 0,\n    cornerRadius: 6,\n    position: 'center',\n    xAdjust: 0,\n    yAdjust: 0,\n    textAlign: 'center',\n    enabled: false,\n    content: null\n  },\n  value: undefined,\n  endValue: undefined,\n  scaleID: undefined,\n  xScaleID: 'x',\n  xMin: undefined,\n  xMax: undefined,\n  yScaleID: 'y',\n  yMin: undefined,\n  yMax: undefined\n};\n\nLineAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\n\nfunction calculateAutoRotation(line) {\n  const {x, y, x2, y2} = line;\n  const rotation = Math.atan2(y2 - y, x2 - x);\n  // Flip the rotation if it goes > PI/2 or < -PI/2, so label stays upright\n  return rotation > PI / 2 ? rotation - PI : rotation < PI / -2 ? rotation + PI : rotation;\n}\n\nfunction drawLabel(ctx, line, chartArea) {\n  const label = line.options.label;\n\n  ctx.font = toFontString(label.font);\n\n  const {width, height} = measureLabel(ctx, label);\n  const rect = line.labelRect = calculateLabelPosition(line, width, height, chartArea);\n\n  ctx.translate(rect.x, rect.y);\n  ctx.rotate(rect.rotation);\n\n  ctx.fillStyle = label.backgroundColor;\n  roundedRect(ctx, -(width / 2), -(height / 2), width, height, label.cornerRadius);\n  ctx.fill();\n\n  ctx.fillStyle = label.color;\n  if (isArray(label.content)) {\n    ctx.textAlign = label.textAlign;\n    const x = calculateLabelXAlignment(label, width);\n    let textYPosition = -(height / 2) + label.yPadding;\n    for (let i = 0; i < label.content.length; i++) {\n      ctx.textBaseline = 'top';\n      ctx.fillText(\n        label.content[i],\n        x,\n        textYPosition\n      );\n      textYPosition += label.font.size + label.yPadding;\n    }\n  } else if (label.content instanceof Image) {\n    const x = -(width / 2) + label.xPadding;\n    const y = -(height / 2) + label.yPadding;\n    ctx.drawImage(label.content, x, y, width - (2 * label.xPadding), height - (2 * label.yPadding));\n  } else {\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText(label.content, 0, 0);\n  }\n}\n\nfunction calculateLabelXAlignment(label, width) {\n  const {textAlign, xPadding} = label;\n  if (textAlign === 'start') {\n    return -(width / 2) + xPadding;\n  } else if (textAlign === 'end') {\n    return +(width / 2) - xPadding;\n  }\n  return 0;\n}\n\nfunction getImageSize(size, value) {\n  if (typeof value === 'number') {\n    return value;\n  } else if (typeof value === 'string') {\n    return toPercent(value) * size;\n  }\n  return size;\n}\n\nconst widthCache = new Map();\nfunction measureLabel(ctx, label) {\n  const content = label.content;\n  if (content instanceof Image) {\n    return {\n      width: getImageSize(content.width, label.width) + 2 * label.xPadding,\n      height: getImageSize(content.height, label.height) + 2 * label.yPadding\n    };\n  }\n  const lines = isArray(content) ? content : [content];\n  const count = lines.length;\n  let width = 0;\n  for (let i = 0; i < count; i++) {\n    const text = lines[i];\n    if (!widthCache.has(text)) {\n      widthCache.set(text, ctx.measureText(text).width);\n    }\n    width = Math.max(width, widthCache.get(text));\n  }\n  width += 2 * label.xPadding;\n\n  return {\n    width,\n    height: count * label.font.size + ((count + 1) * label.yPadding)\n  };\n}\n\nfunction calculateLabelPosition(line, width, height, chartArea) {\n  const label = line.options.label;\n  const {xAdjust, yAdjust, xPadding, yPadding, position} = label;\n  const p1 = {x: line.x, y: line.y};\n  const p2 = {x: line.x2, y: line.y2};\n  const rotation = label.rotation === 'auto' ? calculateAutoRotation(line) : toRadians(label.rotation);\n  const size = rotatedSize(width, height, rotation);\n  const t = calculateT(line, position, size, chartArea);\n  const pt = pointInLine(p1, p2, t);\n  const xCoordinateSizes = {size: size.w, min: chartArea.left, max: chartArea.right, padding: xPadding};\n  const yCoordinateSizes = {size: size.h, min: chartArea.top, max: chartArea.bottom, padding: yPadding};\n\n  return {\n    x: adjustLabelCoordinate(pt.x, xCoordinateSizes) + xAdjust,\n    y: adjustLabelCoordinate(pt.y, yCoordinateSizes) + yAdjust,\n    width,\n    height,\n    rotation\n  };\n}\n\nfunction rotatedSize(width, height, rotation) {\n  const cos = Math.cos(rotation);\n  const sin = Math.sin(rotation);\n  return {\n    w: Math.abs(width * cos) + Math.abs(height * sin),\n    h: Math.abs(width * sin) + Math.abs(height * cos)\n  };\n}\n\nfunction calculateT(line, position, rotSize, chartArea) {\n  let t = 0.5;\n  const space = spaceAround(line, chartArea);\n  const label = line.options.label;\n  if (position === 'start') {\n    t = calculateTAdjust({w: line.x2 - line.x, h: line.y2 - line.y}, rotSize, label, space);\n  } else if (position === 'end') {\n    t = 1 - calculateTAdjust({w: line.x - line.x2, h: line.y - line.y2}, rotSize, label, space);\n  }\n  return t;\n}\n\nfunction calculateTAdjust(lineSize, labelSize, label, space) {\n  const {xPadding, yPadding} = label;\n  const lineW = lineSize.w * space.dx;\n  const lineH = lineSize.h * space.dy;\n  const x = (lineW > 0) && ((labelSize.w / 2 + xPadding - space.x) / lineW);\n  const y = (lineH > 0) && ((labelSize.h / 2 + yPadding - space.y) / lineH);\n  return clamp(Math.max(x, y), 0, 0.25);\n}\n\nfunction spaceAround(line, chartArea) {\n  const {x, x2, y, y2} = line;\n  const t = Math.min(y, y2) - chartArea.top;\n  const l = Math.min(x, x2) - chartArea.left;\n  const b = chartArea.bottom - Math.max(y, y2);\n  const r = chartArea.right - Math.max(x, x2);\n  return {\n    x: Math.min(l, r),\n    y: Math.min(t, b),\n    dx: l < r ? 1 : -1,\n    dy: t < b ? 1 : -1\n  };\n}\n\nfunction adjustLabelCoordinate(coordinate, labelSizes) {\n  const {size, min, max, padding} = labelSizes;\n  const halfSize = size / 2;\n\n  if (size > max - min) {\n    // if it does not fit, display as much as possible\n    return (max + min) / 2;\n  }\n\n  if (min >= (coordinate - padding - halfSize)) {\n    coordinate = min + padding + halfSize;\n  }\n\n  if (max <= (coordinate + padding + halfSize)) {\n    coordinate = max - padding - halfSize;\n  }\n\n  return coordinate;\n}\n\nclass EllipseAnnotation extends BoxAnnotation {\n\n  inRange(x, y) {\n    return pointInEllipse({x, y}, this);\n  }\n\n  draw(ctx) {\n    const {width, height, options} = this;\n    const center = this.getCenterPoint();\n\n    ctx.save();\n\n    ctx.beginPath();\n\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.fillStyle = options.backgroundColor;\n\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n\n    ctx.ellipse(center.x, center.y, height / 2, width / 2, Math.PI / 2, 0, 2 * Math.PI);\n\n    ctx.fill();\n    ctx.stroke();\n\n    ctx.restore();\n  }\n}\n\nEllipseAnnotation.id = 'ellipseAnnotation';\n\nEllipseAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderDash: [],\n  borderDashOffset: 0,\n  borderWidth: 1,\n  xScaleID: 'x',\n  xMin: undefined,\n  xMax: undefined,\n  yScaleID: 'y',\n  yMin: undefined,\n  yMax: undefined\n};\n\nEllipseAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nfunction pointInEllipse(p, ellipse) {\n  const {width, height} = ellipse;\n  const center = ellipse.getCenterPoint(true);\n  const xRadius = width / 2;\n  const yRadius = height / 2;\n\n  if (xRadius <= 0 || yRadius <= 0) {\n    return false;\n  }\n\n  return (Math.pow(p.x - center.x, 2) / Math.pow(xRadius, 2)) + (Math.pow(p.y - center.y, 2) / Math.pow(yRadius, 2)) <= 1.0;\n}\n\nclass PointAnnotation extends Element {\n\n  inRange(x, y) {\n    const {width, options} = this;\n    const center = this.getCenterPoint(true);\n    const radius = width / 2 + options.borderWidth;\n\n    if (radius <= 0) {\n      return false;\n    }\n\n    return (Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2)) <= Math.pow(radius, 2);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n\n  draw(ctx) {\n    const {x, y, width, options} = this;\n\n    ctx.save();\n\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    ctx.fillStyle = options.backgroundColor;\n\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n\n    ctx.beginPath();\n    ctx.arc(x, y, width / 2, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    const {chartArea, scales} = chart;\n    const xScale = scales[options.xScaleID];\n    const yScale = scales[options.yScaleID];\n    let x = chartArea.width / 2;\n    let y = chartArea.height / 2;\n\n    if (xScale) {\n      x = scaleValue(xScale, options.xValue, x);\n    }\n\n    if (yScale) {\n      y = scaleValue(yScale, options.yValue, y);\n    }\n\n    return {\n      x,\n      y,\n      width: options.radius * 2,\n      height: options.radius * 2\n    };\n  }\n}\n\nPointAnnotation.id = 'pointAnnotation';\n\nPointAnnotation.defaults = {\n  display: true,\n  adjustScaleRange: true,\n  borderDash: [],\n  borderDashOffset: 0,\n  borderWidth: 1,\n  radius: 10,\n  xScaleID: 'x',\n  xValue: undefined,\n  yScaleID: 'y',\n  yValue: undefined\n};\n\nPointAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nvar version = \"1.0.2\";\n\nconst chartStates = new Map();\n\nconst annotationTypes = {\n  box: BoxAnnotation,\n  line: LineAnnotation,\n  ellipse: EllipseAnnotation,\n  point: PointAnnotation\n};\n\nObject.keys(annotationTypes).forEach(key => {\n  defaults.describe(`elements.${annotationTypes[key].id}`, {\n    _fallback: 'plugins.annotation'\n  });\n});\n\nvar annotation = {\n  id: 'annotation',\n\n  version,\n\n  afterRegister() {\n    Chart.register(annotationTypes);\n  },\n\n  afterUnregister() {\n    Chart.unregister(annotationTypes);\n  },\n\n  beforeInit(chart) {\n    chartStates.set(chart, {\n      annotations: [],\n      elements: [],\n      listeners: {},\n      listened: false,\n      moveListened: false\n    });\n  },\n\n  beforeUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    const annotations = state.annotations = [];\n\n    let annotationOptions = options.annotations;\n    if (isObject(annotationOptions)) {\n      Object.keys(annotationOptions).forEach(key => {\n        const value = annotationOptions[key];\n        if (isObject(value)) {\n          value.id = key;\n          annotations.push(value);\n        }\n      });\n    } else if (isArray(annotationOptions)) {\n      annotations.push(...annotationOptions);\n    }\n  },\n\n  afterDataLimits(chart, args) {\n    const state = chartStates.get(chart);\n    adjustScaleRange(chart, args.scale, state.annotations.filter(a => a.display && a.adjustScaleRange));\n  },\n\n  afterUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    updateListeners(chart, state, options);\n    updateElements(chart, state, options, args.mode);\n  },\n\n  beforeDatasetsDraw(chart) {\n    draw(chart, 'beforeDatasetsDraw');\n  },\n\n  afterDatasetsDraw(chart) {\n    draw(chart, 'afterDatasetsDraw');\n  },\n\n  beforeDraw(chart) {\n    draw(chart, 'beforeDraw');\n  },\n\n  afterDraw(chart) {\n    draw(chart, 'afterDraw');\n  },\n\n  beforeEvent(chart, args, options) {\n    const state = chartStates.get(chart);\n    handleEvent(chart, state, args.event, options);\n  },\n\n  destroy(chart) {\n    chartStates.delete(chart);\n  },\n\n  _getState(chart) {\n    return chartStates.get(chart);\n  },\n\n  defaults: {\n    drawTime: 'afterDatasetsDraw',\n    dblClickSpeed: 350, // ms\n    animations: {\n      numbers: {\n        properties: ['x', 'y', 'x2', 'y2', 'width', 'height'],\n        type: 'number'\n      },\n    },\n    label: {\n      drawTime: null\n    }\n  },\n\n  descriptors: {\n    _indexable: false,\n    _scriptable: (prop) => !hooks.includes(prop),\n    annotations: {\n      _allKeys: false,\n      _fallback: (prop, opts) => `elements.${annotationTypes[opts.type || 'line'].id}`,\n    },\n  },\n\n  additionalOptionScopes: ['']\n};\n\nconst directUpdater = {\n  update: Object.assign\n};\n\nfunction resolveAnimations(chart, animOpts, mode) {\n  if (mode === 'reset' || mode === 'none' || mode === 'resize') {\n    return directUpdater;\n  }\n  return new Animations(chart, animOpts);\n}\n\nfunction updateElements(chart, state, options, mode) {\n  const animations = resolveAnimations(chart, options.animations, mode);\n\n  const annotations = state.annotations;\n  const elements = resyncElements(state.elements, annotations);\n\n  for (let i = 0; i < annotations.length; i++) {\n    const annotation = annotations[i];\n    let el = elements[i];\n    const elType = annotationTypes[annotation.type] || annotationTypes.line;\n    if (!el || !(el instanceof elType)) {\n      el = elements[i] = new elType();\n    }\n    const opts = resolveAnnotationOptions(annotation.setContext(getContext(chart, el, annotation)));\n    const properties = el.resolveElementProperties(chart, opts);\n    properties.skip = isNaN(properties.x) || isNaN(properties.y);\n    properties.options = opts;\n    animations.update(el, properties);\n  }\n}\n\nfunction resolveAnnotationOptions(resolver) {\n  const elType = annotationTypes[resolver.type] || annotationTypes.line;\n  const result = {};\n  result.id = resolver.id;\n  result.type = resolver.type;\n  result.drawTime = resolver.drawTime;\n  Object.assign(result, resolveObj(resolver, elType.defaults), resolveObj(resolver, elType.defaultRoutes));\n  for (const hook of hooks) {\n    result[hook] = resolver[hook];\n  }\n  return result;\n}\n\nfunction resolveObj(resolver, defs) {\n  const result = {};\n  for (const name of Object.keys(defs)) {\n    const optDefs = defs[name];\n    const value = resolver[name];\n    result[name] = isObject(optDefs) ? resolveObj(value, optDefs) : value;\n  }\n  return result;\n}\n\nfunction getContext(chart, element, annotation) {\n  return element.$context || (element.$context = Object.assign(Object.create(chart.getContext()), {\n    element,\n    id: annotation.id,\n    type: 'annotation'\n  }));\n}\n\nfunction resyncElements(elements, annotations) {\n  const count = annotations.length;\n  const start = elements.length;\n\n  if (start < count) {\n    const add = count - start;\n    elements.splice(start, 0, ...new Array(add));\n  } else if (start > count) {\n    elements.splice(count, start - count);\n  }\n  return elements;\n}\n\nfunction draw(chart, caller) {\n  const {ctx, chartArea} = chart;\n  const state = chartStates.get(chart);\n  const elements = state.elements.filter(el => !el.skip && el.options.display);\n\n  clipArea(ctx, chartArea);\n  elements.forEach(el => {\n    if (el.options.drawTime === caller) {\n      el.draw(ctx);\n    }\n  });\n  unclipArea(ctx);\n\n  elements.forEach(el => {\n    if ('drawLabel' in el && el.options.label && (el.options.label.drawTime || el.options.drawTime) === caller) {\n      el.drawLabel(ctx, chartArea);\n    }\n  });\n}\n\nfunction adjustScaleRange(chart, scale, annotations) {\n  const range = getScaleLimits(scale, annotations);\n  let changed = false;\n  if (isFinite(range.min) &&\n\t\ttypeof scale.options.min === 'undefined' &&\n\t\ttypeof scale.options.suggestedMin === 'undefined') {\n    changed = scale.min !== range.min;\n    scale.min = range.min;\n  }\n  if (isFinite(range.max) &&\n\t\ttypeof scale.options.max === 'undefined' &&\n\t\ttypeof scale.options.suggestedMax === 'undefined') {\n    changed = scale.max !== range.max;\n    scale.max = range.max;\n  }\n  if (changed && typeof scale.handleTickRangeOptions === 'function') {\n    scale.handleTickRangeOptions();\n  }\n}\n\nfunction getScaleLimits(scale, annotations) {\n  const axis = scale.axis;\n  const scaleID = scale.id;\n  const scaleIDOption = axis + 'ScaleID';\n  let min = valueOrDefault(scale.min, Number.NEGATIVE_INFINITY);\n  let max = valueOrDefault(scale.max, Number.POSITIVE_INFINITY);\n  for (const annotation of annotations) {\n    if (annotation.scaleID === scaleID) {\n      for (const prop of ['value', 'endValue']) {\n        const raw = annotation[prop];\n        if (raw) {\n          const value = scale.parse(raw);\n          min = Math.min(min, value);\n          max = Math.max(max, value);\n        }\n      }\n    } else if (annotation[scaleIDOption] === scaleID) {\n      for (const prop of [axis + 'Min', axis + 'Max', axis + 'Value']) {\n        const raw = annotation[prop];\n        if (raw) {\n          const value = scale.parse(raw);\n          min = Math.min(min, value);\n          max = Math.max(max, value);\n        }\n      }\n    }\n  }\n  return {min, max};\n}\n\nexport default annotation;\n"]},"metadata":{},"sourceType":"module"}